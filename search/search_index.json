{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to K65 K65 is a compiler for 6502 CPU architecture. At this moment it supports Atari 8-bit (400/800/XL/XE), Commodore 64 and Atari 2600 as target platforms. Dowloads Current release K65 SDK version 0.2.1 Older releases K65 SDK version 0.2.0 K65 SDK version 0.1.2 Changelog SDK 0.2.1 New example Atari 2600 demo sources included: Ascend and Derivative 2600 by Cluster & DMA Linker now reports final section sizes again Minor compiler bugfixes FIX : Atari XL/XE and C64 systems sometimes exported truncated images This documentation is currently being built.","title":"Home"},{"location":"#welcome-to-k65","text":"K65 is a compiler for 6502 CPU architecture. At this moment it supports Atari 8-bit (400/800/XL/XE), Commodore 64 and Atari 2600 as target platforms.","title":"Welcome to K65"},{"location":"#dowloads","text":"","title":"Dowloads"},{"location":"#current-release","text":"K65 SDK version 0.2.1","title":"Current release"},{"location":"#older-releases","text":"K65 SDK version 0.2.0 K65 SDK version 0.1.2","title":"Older releases"},{"location":"#changelog","text":"","title":"Changelog"},{"location":"#sdk-021","text":"New example Atari 2600 demo sources included: Ascend and Derivative 2600 by Cluster & DMA Linker now reports final section sizes again Minor compiler bugfixes FIX : Atari XL/XE and C64 systems sometimes exported truncated images This documentation is currently being built.","title":"SDK 0.2.1"},{"location":"evaluator/","text":"Evaluator in K65 is compile-time executed expression language very similar to C/C++ expressions. Introduction In every place where the compiler expects a single number, you can invoke the evaluator by simply using square brackets. data NumberFour { [2+2] } The evaluator can be also invoked freely outside any section body, e.g. to set variables: [ FOUR = 4 ] which can be later used freely as compiler constants and within further evaluator expressions: data FourFiveSix { FOUR // value of variable FOUR defined earlier [FIVE = FOUR+1] // defines variable FIVE and returns its value [FIVE+1] // uses recently set FIVE value } Operators Available operators and their precedence levels are similar to operators in C and C++ , operators are sorted by precedence from highest to lowest: Precedence 2 Associativity: left-to-right Operator Description ++ -- () [] . suffix incremen suffix decrement function call array subscripting single argument function call Precedence 3 Associativity: right-to-left Operator Description ++ -- + - ! ~ prefix increment prefix decrement unary plus unary minus logical NOT bitwise NOT (One's Complement) Precedence 5 Associativity: left-to-right Operator Description * / % multiplication division modulo (remainder) Precedence 6 Associativity: left-to-right Operator Description + - addition subtraction Precedence 7 Associativity: left-to-right Operator Description << >> bitwise left shift bitwise right shift Precedence 8 Associativity: left-to-right Operator Description < <= > >= ?> ?< less than less than or equal to greater than greater than or equal to select greater value (maximum) select smaller value (minimum) Precedence 9 Associativity: left-to-right Operator Description == != equal to not equal to Precedence 10 Associativity: left-to-right Operator Descriptiont & bitwise AND Precedence 11 Associativity: left-to-right Operator Description ^ bitwise XOR (exclusive or) Precedence 12 Associativity: left-to-right Operator Description | bitwise OR (inclusive or) Precedence 13 Associativity: left-to-right Operator Description && logical AND Precedence 14 Associativity: left-to-right Operator Description || logical OR Precedence 15 Associativity: right-to-left Operator Description ?: lternary conditional Precedence 16 Associativity: right-to-left Operator Description = += -= *= /= %= <<= >>= &= ^= |= direct assignment assignment by sum assignment by difference assignment by product assignment by quotient assignment by remainder assignment by bitwise left shift assignment by bitwise right shift assignment by bitwise AND assignment by bitwise XOR assignment by bitwise OR Precedence 18 Associativity: left-to-right Operator Description , expression list (executes in sequence, returns value of the last) Functions acos( x ) Arcus cosinus addbyte( sec, b ) Add byte b to section sec asin( x ) Arcus sinus ceil( x ) Round up to nearest integer clamp( x, min, max ) Clamp x to range min to max color( r, g, b ) Return palette index for nearest color to color (r,g,b) color( x ) Return palette index for nearest color specified in format 0xRRGGBB cos( x ) Cosinus error( err ) Print error message err ane terminate compilation floor( x ) Round down to nearest integer frac( x ) Get fractional part ( x-floor(x) ) index( tab, x ) 1-dimensional indexing operator ( same as tab[x] ) index( tab, x, y ) 2-dimensional indexing operator ( same as tab[x,y] ) max( a, b ) Maximum min( a, b ) Minimum pow( x, y ) Power function print( msg ) Print message msg rnd( ) Random value 0 <= x < 1 round( x ) Round to nearest integer sin( x ) Sinus size( sec ) Current size of section sec sqrt( x ) Square root","title":"Evaluator"},{"location":"evaluator/#_1","text":"Evaluator in K65 is compile-time executed expression language very similar to C/C++ expressions.","title":""},{"location":"evaluator/#introduction","text":"In every place where the compiler expects a single number, you can invoke the evaluator by simply using square brackets. data NumberFour { [2+2] } The evaluator can be also invoked freely outside any section body, e.g. to set variables: [ FOUR = 4 ] which can be later used freely as compiler constants and within further evaluator expressions: data FourFiveSix { FOUR // value of variable FOUR defined earlier [FIVE = FOUR+1] // defines variable FIVE and returns its value [FIVE+1] // uses recently set FIVE value }","title":"Introduction"},{"location":"evaluator/#operators","text":"Available operators and their precedence levels are similar to operators in C and C++ , operators are sorted by precedence from highest to lowest:","title":"Operators"},{"location":"evaluator/#precedence-2","text":"Associativity: left-to-right Operator Description ++ -- () [] . suffix incremen suffix decrement function call array subscripting single argument function call","title":"Precedence 2"},{"location":"evaluator/#precedence-3","text":"Associativity: right-to-left Operator Description ++ -- + - ! ~ prefix increment prefix decrement unary plus unary minus logical NOT bitwise NOT (One's Complement)","title":"Precedence 3"},{"location":"evaluator/#precedence-5","text":"Associativity: left-to-right Operator Description * / % multiplication division modulo (remainder)","title":"Precedence 5"},{"location":"evaluator/#precedence-6","text":"Associativity: left-to-right Operator Description + - addition subtraction","title":"Precedence 6"},{"location":"evaluator/#precedence-7","text":"Associativity: left-to-right Operator Description << >> bitwise left shift bitwise right shift","title":"Precedence 7"},{"location":"evaluator/#precedence-8","text":"Associativity: left-to-right Operator Description < <= > >= ?> ?< less than less than or equal to greater than greater than or equal to select greater value (maximum) select smaller value (minimum)","title":"Precedence 8"},{"location":"evaluator/#precedence-9","text":"Associativity: left-to-right Operator Description == != equal to not equal to","title":"Precedence 9"},{"location":"evaluator/#precedence-10","text":"Associativity: left-to-right Operator Descriptiont & bitwise AND","title":"Precedence 10"},{"location":"evaluator/#precedence-11","text":"Associativity: left-to-right Operator Description ^ bitwise XOR (exclusive or)","title":"Precedence 11"},{"location":"evaluator/#precedence-12","text":"Associativity: left-to-right Operator Description | bitwise OR (inclusive or)","title":"Precedence 12"},{"location":"evaluator/#precedence-13","text":"Associativity: left-to-right Operator Description && logical AND","title":"Precedence 13"},{"location":"evaluator/#precedence-14","text":"Associativity: left-to-right Operator Description || logical OR","title":"Precedence 14"},{"location":"evaluator/#precedence-15","text":"Associativity: right-to-left Operator Description ?: lternary conditional","title":"Precedence 15"},{"location":"evaluator/#precedence-16","text":"Associativity: right-to-left Operator Description = += -= *= /= %= <<= >>= &= ^= |= direct assignment assignment by sum assignment by difference assignment by product assignment by quotient assignment by remainder assignment by bitwise left shift assignment by bitwise right shift assignment by bitwise AND assignment by bitwise XOR assignment by bitwise OR","title":"Precedence 16"},{"location":"evaluator/#precedence-18","text":"Associativity: left-to-right Operator Description , expression list (executes in sequence, returns value of the last)","title":"Precedence 18"},{"location":"evaluator/#functions","text":"","title":"Functions"},{"location":"evaluator/#acos-x","text":"Arcus cosinus","title":"acos( x )"},{"location":"evaluator/#addbyte-sec-b","text":"Add byte b to section sec","title":"addbyte( sec, b )"},{"location":"evaluator/#asin-x","text":"Arcus sinus","title":"asin( x )"},{"location":"evaluator/#ceil-x","text":"Round up to nearest integer","title":"ceil( x )"},{"location":"evaluator/#clamp-x-min-max","text":"Clamp x to range min to max","title":"clamp( x, min, max )"},{"location":"evaluator/#color-r-g-b","text":"Return palette index for nearest color to color (r,g,b)","title":"color( r, g, b )"},{"location":"evaluator/#color-x","text":"Return palette index for nearest color specified in format 0xRRGGBB","title":"color( x )"},{"location":"evaluator/#cos-x","text":"Cosinus","title":"cos( x )"},{"location":"evaluator/#error-err","text":"Print error message err ane terminate compilation","title":"error( err )"},{"location":"evaluator/#floor-x","text":"Round down to nearest integer","title":"floor( x )"},{"location":"evaluator/#frac-x","text":"Get fractional part ( x-floor(x) )","title":"frac( x )"},{"location":"evaluator/#index-tab-x","text":"1-dimensional indexing operator ( same as tab[x] )","title":"index( tab, x )"},{"location":"evaluator/#index-tab-x-y","text":"2-dimensional indexing operator ( same as tab[x,y] )","title":"index( tab, x, y )"},{"location":"evaluator/#max-a-b","text":"Maximum","title":"max( a, b )"},{"location":"evaluator/#min-a-b","text":"Minimum","title":"min( a, b )"},{"location":"evaluator/#pow-x-y","text":"Power function","title":"pow( x, y )"},{"location":"evaluator/#print-msg","text":"Print message msg","title":"print( msg )"},{"location":"evaluator/#rnd","text":"Random value 0 <= x < 1","title":"rnd( )"},{"location":"evaluator/#round-x","text":"Round to nearest integer","title":"round( x )"},{"location":"evaluator/#sin-x","text":"Sinus","title":"sin( x )"},{"location":"evaluator/#size-sec","text":"Current size of section sec","title":"size( sec )"},{"location":"evaluator/#sqrt-x","text":"Square root","title":"sqrt( x )"},{"location":"examples/","text":"Scripts Project example files main.k65proj -system AtariXL -lowAddr 0x2000 ../../include/defs.k65 main main.k65 main -o main.xex -link !atari800 main.xex make K65=${K65_HOME}/bin/k65 all: main clean main: $(K65) @main.k65proj clean: rm main.gmap main.lst main.sym Atari 800 XL Rainbow main { { COLPF2=a=VCOUNT WSYNC=a } always } Starfield var PCOLR0 = 0x02C0 data stars { align 256 for x=0..255 eval [ rnd() & 255 ] } data speed { align 256 for x=0..255 eval [ (rnd() & 3) + 1 ] } main { PCOLR0=a=14 GRAFM=a { a=0 { a?VCOUNT } != x=0 { WSYNC=a HPOSM0=a=stars,x a=stars,x a+speed,x stars,x=a x++ } != } always } DLI example var VDSLST = 0x0200 var SDLST = 0x0230 var screen = 0x8000 data displist { nocross 0x70 0x70 0x70 0x42 &<screen &>screen 2 2 2 0xF0 2 2 2 2 0x41 &<displist &>displist } naked dli { a!! COLPF2=a=0xDE WSYNC=a a?? return_i } main { SDLST=a=&<displist SDLST+1=a=&>displist VDSLST=a=&<dli VDSLST+1=a=&>dli NMIEN=a=0xC0 {} always } Flame //------------------------------------------------------------------------------ // Flame by koalka/bbsl/karzelki //------------------------------------------------------------------------------ var RTCLOK = 0x0014 var SDLSTL = 0x0230 var SDLSTH = 0x0231 var SDMCTL = 0x022F var GPRIOR = 0x026F var COLOR4 = 0x02C8 var CHBAS = 0x02F4 var fonts = 0x6000 var screen = 0x6400 data dl { nocross 0x42 &<screen &>screen for x=0..19 eval [2] 0x41 &<dl &>dl } inline pause { a=RTCLOK { a?RTCLOK } == } main { COLOR4=a=0x20 CHBAS=a=&>fonts SDLSTL=a=&<dl SDLSTH=a=&>dl GPRIOR=a=0x40 SDMCTL=a=0x21 a=0 x=a y=a { screen,x=a screen+0x100,x=a screen+0x200,x=a screen+0x300,x=a x++ } != { { fonts,x=a x++ y++ y?8 } != y=0 c- a+0x11 } < { { a=screen-1,y c- a+screen,y a+screen+1,y a+screen+32,y a>> a>> screen-31,y=a a=screen+0xFF,y c- a+screen+0x100,y a+screen+0x101,y a+screen+0x120,y a>> a>> screen+0xE1,y=a a=screen+0x1FF,y c- a+screen+0x200,y a+screen+0x201,y a+screen+0x220,y a>> a>> screen+0x1E1,y=a y++ } != COLBK=a=10 pause x=0x1F { a=RANDOM a&15 screen+0x2E0,x=a x-- } >=0 } always } Mode 9++/10++ // Mode 9++ GPRIOR=a=0x40 // Mode 10++ GPRIOR=a=0x81 var VDSLST=0x0200, SDLSTL=0x0230, SDMCTL=0x022F, GPRIOR=0x026F var screen = 0xF000 data dl { nocross 0x90 0x6F &<screen &>screen for x=1..58 eval [ x&1 ? 0x8F : 0x2F ] 0x41 &<dl &>dl } naked dli { a!! WSYNC=a VSCROL=a=13 VSCROL=a=3 a?? return_i } main { VDSLST=a=&<dli VDSLST+1=a=&>dli SDLSTL=a=&<dl SDLSTL+1=a=&>dl SDMCTL=a=0x22 GPRIOR=a=0x40 NMIEN=a=0xC0 {} always } Quatari landcape //------------------------------------------------------------------------------ // This is a part of Quatari 256B intro // https://demozoo.org/productions/280623 // for 8bit AtariXL, OS Rev 2 //------------------------------------------------------------------------------ var CURSOR_Y = 0x54 var CURSOR_X = 0x55 var PREV_Y = 0x5A var PREV_X = 0x5B var iter = 0x80 var COLOR4 = 0x02C8 var COLOR = 0x02FB var RND = 0xD20A var openmode = 0xEF9C var drawto = 0xF9C2 data colorHeight { 170 150 144 144 122 122 110 110 94 94 86 86 82 80 } main { a=9 call openmode COLOR4=a=0xB0 iter=a=79 { CURSOR_X=a=iter PREV_X=a PREV_Y=a=1 COLOR=a=13 { x=COLOR CURSOR_Y=a=colorHeight,x a=RND <0 { colorHeight,x++ } a=RND <0 { colorHeight,x-- } call drawto COLOR-- } >=0 iter-- } != {} always } Screensaver var LNFLG = 0, RTCLOK = 0x14, tmp = 0x80 main { a=0x3f tmp=a a=0xff x=0xf { HPOSP0,x=a x-- } >=0 { .start: WSYNC=a a=LNFLG LNFLG++ a^0x20 HPOSP0=a a^tmp HPOSP1=a a=VCOUNT COLPM0=a a^0xff COLPM1=a a=VCOUNT a?0x40 < goto .jump LNFLG-- LNFLG-- .jump: a=VCOUNT != goto .start a=RTCLOK LNFLG=a a&0x7f != goto .start tmp++ } always }","title":"Examples"},{"location":"examples/#_1","text":"","title":""},{"location":"examples/#scripts","text":"","title":"Scripts"},{"location":"examples/#project-example-files","text":"main.k65proj -system AtariXL -lowAddr 0x2000 ../../include/defs.k65 main main.k65 main -o main.xex -link !atari800 main.xex make K65=${K65_HOME}/bin/k65 all: main clean main: $(K65) @main.k65proj clean: rm main.gmap main.lst main.sym","title":"Project example files"},{"location":"examples/#atari-800-xl","text":"","title":"Atari 800 XL"},{"location":"examples/#rainbow","text":"main { { COLPF2=a=VCOUNT WSYNC=a } always }","title":"Rainbow"},{"location":"examples/#starfield","text":"var PCOLR0 = 0x02C0 data stars { align 256 for x=0..255 eval [ rnd() & 255 ] } data speed { align 256 for x=0..255 eval [ (rnd() & 3) + 1 ] } main { PCOLR0=a=14 GRAFM=a { a=0 { a?VCOUNT } != x=0 { WSYNC=a HPOSM0=a=stars,x a=stars,x a+speed,x stars,x=a x++ } != } always }","title":"Starfield"},{"location":"examples/#dli-example","text":"var VDSLST = 0x0200 var SDLST = 0x0230 var screen = 0x8000 data displist { nocross 0x70 0x70 0x70 0x42 &<screen &>screen 2 2 2 0xF0 2 2 2 2 0x41 &<displist &>displist } naked dli { a!! COLPF2=a=0xDE WSYNC=a a?? return_i } main { SDLST=a=&<displist SDLST+1=a=&>displist VDSLST=a=&<dli VDSLST+1=a=&>dli NMIEN=a=0xC0 {} always }","title":"DLI example"},{"location":"examples/#flame","text":"//------------------------------------------------------------------------------ // Flame by koalka/bbsl/karzelki //------------------------------------------------------------------------------ var RTCLOK = 0x0014 var SDLSTL = 0x0230 var SDLSTH = 0x0231 var SDMCTL = 0x022F var GPRIOR = 0x026F var COLOR4 = 0x02C8 var CHBAS = 0x02F4 var fonts = 0x6000 var screen = 0x6400 data dl { nocross 0x42 &<screen &>screen for x=0..19 eval [2] 0x41 &<dl &>dl } inline pause { a=RTCLOK { a?RTCLOK } == } main { COLOR4=a=0x20 CHBAS=a=&>fonts SDLSTL=a=&<dl SDLSTH=a=&>dl GPRIOR=a=0x40 SDMCTL=a=0x21 a=0 x=a y=a { screen,x=a screen+0x100,x=a screen+0x200,x=a screen+0x300,x=a x++ } != { { fonts,x=a x++ y++ y?8 } != y=0 c- a+0x11 } < { { a=screen-1,y c- a+screen,y a+screen+1,y a+screen+32,y a>> a>> screen-31,y=a a=screen+0xFF,y c- a+screen+0x100,y a+screen+0x101,y a+screen+0x120,y a>> a>> screen+0xE1,y=a a=screen+0x1FF,y c- a+screen+0x200,y a+screen+0x201,y a+screen+0x220,y a>> a>> screen+0x1E1,y=a y++ } != COLBK=a=10 pause x=0x1F { a=RANDOM a&15 screen+0x2E0,x=a x-- } >=0 } always }","title":"Flame"},{"location":"examples/#mode-910","text":"// Mode 9++ GPRIOR=a=0x40 // Mode 10++ GPRIOR=a=0x81 var VDSLST=0x0200, SDLSTL=0x0230, SDMCTL=0x022F, GPRIOR=0x026F var screen = 0xF000 data dl { nocross 0x90 0x6F &<screen &>screen for x=1..58 eval [ x&1 ? 0x8F : 0x2F ] 0x41 &<dl &>dl } naked dli { a!! WSYNC=a VSCROL=a=13 VSCROL=a=3 a?? return_i } main { VDSLST=a=&<dli VDSLST+1=a=&>dli SDLSTL=a=&<dl SDLSTL+1=a=&>dl SDMCTL=a=0x22 GPRIOR=a=0x40 NMIEN=a=0xC0 {} always }","title":"Mode 9++/10++"},{"location":"examples/#quatari-landcape","text":"//------------------------------------------------------------------------------ // This is a part of Quatari 256B intro // https://demozoo.org/productions/280623 // for 8bit AtariXL, OS Rev 2 //------------------------------------------------------------------------------ var CURSOR_Y = 0x54 var CURSOR_X = 0x55 var PREV_Y = 0x5A var PREV_X = 0x5B var iter = 0x80 var COLOR4 = 0x02C8 var COLOR = 0x02FB var RND = 0xD20A var openmode = 0xEF9C var drawto = 0xF9C2 data colorHeight { 170 150 144 144 122 122 110 110 94 94 86 86 82 80 } main { a=9 call openmode COLOR4=a=0xB0 iter=a=79 { CURSOR_X=a=iter PREV_X=a PREV_Y=a=1 COLOR=a=13 { x=COLOR CURSOR_Y=a=colorHeight,x a=RND <0 { colorHeight,x++ } a=RND <0 { colorHeight,x-- } call drawto COLOR-- } >=0 iter-- } != {} always }","title":"Quatari landcape"},{"location":"examples/#screensaver","text":"var LNFLG = 0, RTCLOK = 0x14, tmp = 0x80 main { a=0x3f tmp=a a=0xff x=0xf { HPOSP0,x=a x-- } >=0 { .start: WSYNC=a a=LNFLG LNFLG++ a^0x20 HPOSP0=a a^tmp HPOSP1=a a=VCOUNT COLPM0=a a^0xff COLPM1=a a=VCOUNT a?0x40 < goto .jump LNFLG-- LNFLG-- .jump: a=VCOUNT != goto .start a=RTCLOK LNFLG=a a&0x7f != goto .start tmp++ } always }","title":"Screensaver"},{"location":"instructions/","text":"K65 compiler supports following 6502 instructions. TBD value means that instruction support is planned, but currently not implemented. Standard 6502 opcodes ADC add with carry Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a+imm a+mem a+mem,x a+mem,y a+(mem,x) a+(mem),y AND and (with accumulator) Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a&imm a&mem a&mem,x a&mem,y a&(mem,x) a&(mem),y ASL arithmetic shift left Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a<< mem<< mem,x<< BCC branch on carry clear >={ ... } < goto label { ... } < c+{ ... } c- goto label { ... } c- BCS branch on carry clear <{ ... } >= goto label { ... } >= c-{ ... } c+ goto label { ... } c+ BEQ branch on equal (zero set) { ... } == goto label { ... } == BIT bit test Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a&?mem BMI branch on minus (negative set) >=0{ ... } <0 goto label { ... } <0 BNE branch on not equal (zero clear) =={ ... } != goto label { ... } != BPL branch on plus (negative clear) <0{ ... } >=0 goto label { ... } >=0 BRK interrupt /* TBD */ BVC branch on overflow clear <<={ ... } >>= goto label { ... } >>= o+{ ... } o- goto label { ... } o- BVS branch on overflow set >>={ ... } <<= goto label { ... } <<= o-{ ... } o+ goto label { ... } o+ CLC clear carry Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) c- CLD clear decimal Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) d- CLI clear interrupt disable Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) i- CLV clear overflow Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) o- CMP compare (with accumulator) Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a?imm a?mem a?mem,x a?mem,y a?(mem,x) a?(mem),y CPX compare with X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x?imm x?mem CPY compare with Y Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y?imm y?mem DEC decrement Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem-- mem,x-- DEX decrement X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x-- DEY decrement Y Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y-- EOR exclusive or (with accumulator) Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a^imm a^mem a^mem,x a^mem,y a^(mem,x) a^(mem),y INC increment Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem++ mem,x++ INX increment X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x++ INY increment X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y++ JMP jump Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) goto mem goto (mem) JSR jump subroutine Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) call mem LDA load accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a=imm a=mem a=mem,x a=mem,y a=(mem,x) a=(mem),y LDX load X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x=imm x=mem x=mem,y LDY load Y Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y=imm y=mem y=mem,x LSR logical shift right Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a>> mem>> mem,x>> NOP no operation * for single NOP *<number> to wait <number> of cycles ORA or with accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) imm mem mem,x mem,y (mem,x) (mem),y PHA push accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a!! PHP push processor status (SR) Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) flag!! PLA pull accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a?? PLP pull processor status (SR) Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) flag?? ROL rotate left Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a<<< mem<<< mem,x<<< ROR rotate right Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a>>> mem>>> mem,x>>> RTI return from interrupt Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) return_i RTS return from subroutine Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) return SBC subtract with carry Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a-imm a-mem a-mem,x a-mem,y a-(mem,x) a-(mem),y SEC set carry Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) c+ SED set decimal Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) d+ SEI set interrupt disable Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) i+ STA store accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem=a mem,x=a mem,y=a (mem,x)=a (mem),y=a STX store X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem=x STY store Y Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem=y TAX transfer accumulator to X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x-a TAY transfer accumulator to Y Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y=a TSX transfer stack pointer to X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x=s TXA transfer X to accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a=x TXS transfer X to stack pointer Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) s=x TYA transfer Y to accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a=y","title":"Instructions"},{"location":"instructions/#_1","text":"K65 compiler supports following 6502 instructions. TBD value means that instruction support is planned, but currently not implemented.","title":""},{"location":"instructions/#standard-6502-opcodes","text":"","title":"Standard 6502 opcodes"},{"location":"instructions/#adc-add-with-carry","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a+imm a+mem a+mem,x a+mem,y a+(mem,x) a+(mem),y","title":"ADC add with carry"},{"location":"instructions/#and-and-with-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a&imm a&mem a&mem,x a&mem,y a&(mem,x) a&(mem),y","title":"AND and (with accumulator)"},{"location":"instructions/#asl-arithmetic-shift-left","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a<< mem<< mem,x<<","title":"ASL arithmetic shift left"},{"location":"instructions/#bcc-branch-on-carry-clear","text":">={ ... } < goto label { ... } < c+{ ... } c- goto label { ... } c-","title":"BCC branch on carry clear"},{"location":"instructions/#bcs-branch-on-carry-clear","text":"<{ ... } >= goto label { ... } >= c-{ ... } c+ goto label { ... } c+","title":"BCS branch on carry clear"},{"location":"instructions/#beq-branch-on-equal-zero-set","text":"{ ... } == goto label { ... } ==","title":"BEQ branch on equal (zero set)"},{"location":"instructions/#bit-bit-test","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a&?mem","title":"BIT bit test"},{"location":"instructions/#bmi-branch-on-minus-negative-set","text":">=0{ ... } <0 goto label { ... } <0","title":"BMI branch on minus (negative set)"},{"location":"instructions/#bne-branch-on-not-equal-zero-clear","text":"=={ ... } != goto label { ... } !=","title":"BNE branch on not equal (zero clear)"},{"location":"instructions/#bpl-branch-on-plus-negative-clear","text":"<0{ ... } >=0 goto label { ... } >=0","title":"BPL branch on plus (negative clear)"},{"location":"instructions/#brk-interrupt","text":"/* TBD */","title":"BRK interrupt"},{"location":"instructions/#bvc-branch-on-overflow-clear","text":"<<={ ... } >>= goto label { ... } >>= o+{ ... } o- goto label { ... } o-","title":"BVC branch on overflow clear"},{"location":"instructions/#bvs-branch-on-overflow-set","text":">>={ ... } <<= goto label { ... } <<= o-{ ... } o+ goto label { ... } o+","title":"BVS branch on overflow set"},{"location":"instructions/#clc-clear-carry","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) c-","title":"CLC clear carry"},{"location":"instructions/#cld-clear-decimal","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) d-","title":"CLD clear decimal"},{"location":"instructions/#cli-clear-interrupt-disable","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) i-","title":"CLI clear interrupt disable"},{"location":"instructions/#clv-clear-overflow","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) o-","title":"CLV clear overflow"},{"location":"instructions/#cmp-compare-with-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a?imm a?mem a?mem,x a?mem,y a?(mem,x) a?(mem),y","title":"CMP compare (with accumulator)"},{"location":"instructions/#cpx-compare-with-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x?imm x?mem","title":"CPX compare with X"},{"location":"instructions/#cpy-compare-with-y","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y?imm y?mem","title":"CPY compare with Y"},{"location":"instructions/#dec-decrement","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem-- mem,x--","title":"DEC decrement"},{"location":"instructions/#dex-decrement-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x--","title":"DEX decrement X"},{"location":"instructions/#dey-decrement-y","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y--","title":"DEY decrement Y"},{"location":"instructions/#eor-exclusive-or-with-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a^imm a^mem a^mem,x a^mem,y a^(mem,x) a^(mem),y","title":"EOR exclusive or (with accumulator)"},{"location":"instructions/#inc-increment","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem++ mem,x++","title":"INC increment"},{"location":"instructions/#inx-increment-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x++","title":"INX increment X"},{"location":"instructions/#iny-increment-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y++","title":"INY increment X"},{"location":"instructions/#jmp-jump","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) goto mem goto (mem)","title":"JMP jump"},{"location":"instructions/#jsr-jump-subroutine","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) call mem","title":"JSR jump subroutine"},{"location":"instructions/#lda-load-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a=imm a=mem a=mem,x a=mem,y a=(mem,x) a=(mem),y","title":"LDA load accumulator"},{"location":"instructions/#ldx-load-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x=imm x=mem x=mem,y","title":"LDX load X"},{"location":"instructions/#ldy-load-y","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y=imm y=mem y=mem,x","title":"LDY load Y"},{"location":"instructions/#lsr-logical-shift-right","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a>> mem>> mem,x>>","title":"LSR logical shift right"},{"location":"instructions/#nop-no-operation","text":"* for single NOP *<number> to wait <number> of cycles","title":"NOP no operation"},{"location":"instructions/#ora-or-with-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) imm mem mem,x mem,y (mem,x) (mem),y","title":"ORA or with accumulator"},{"location":"instructions/#pha-push-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a!!","title":"PHA push accumulator"},{"location":"instructions/#php-push-processor-status-sr","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) flag!!","title":"PHP push processor status (SR)"},{"location":"instructions/#pla-pull-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a??","title":"PLA pull accumulator"},{"location":"instructions/#plp-pull-processor-status-sr","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) flag??","title":"PLP pull processor status (SR)"},{"location":"instructions/#rol-rotate-left","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a<<< mem<<< mem,x<<<","title":"ROL rotate left"},{"location":"instructions/#ror-rotate-right","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a>>> mem>>> mem,x>>>","title":"ROR rotate right"},{"location":"instructions/#rti-return-from-interrupt","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) return_i","title":"RTI return from interrupt"},{"location":"instructions/#rts-return-from-subroutine","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) return","title":"RTS return from subroutine"},{"location":"instructions/#sbc-subtract-with-carry","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a-imm a-mem a-mem,x a-mem,y a-(mem,x) a-(mem),y","title":"SBC subtract with carry"},{"location":"instructions/#sec-set-carry","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) c+","title":"SEC set carry"},{"location":"instructions/#sed-set-decimal","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) d+","title":"SED set decimal"},{"location":"instructions/#sei-set-interrupt-disable","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) i+","title":"SEI set interrupt disable"},{"location":"instructions/#sta-store-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem=a mem,x=a mem,y=a (mem,x)=a (mem),y=a","title":"STA store accumulator"},{"location":"instructions/#stx-store-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem=x","title":"STX store X"},{"location":"instructions/#sty-store-y","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem=y","title":"STY store Y"},{"location":"instructions/#tax-transfer-accumulator-to-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x-a","title":"TAX transfer accumulator to X"},{"location":"instructions/#tay-transfer-accumulator-to-y","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y=a","title":"TAY transfer accumulator to Y"},{"location":"instructions/#tsx-transfer-stack-pointer-to-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x=s","title":"TSX transfer stack pointer to X"},{"location":"instructions/#txa-transfer-x-to-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a=x","title":"TXA transfer X to accumulator"},{"location":"instructions/#txs-transfer-x-to-stack-pointer","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) s=x","title":"TXS transfer X to stack pointer"},{"location":"instructions/#tya-transfer-y-to-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a=y","title":"TYA transfer Y to accumulator"},{"location":"known-bugs/","text":"Accidential bank switching can occur when branch instruction jumps back from last bank to previous bank. Example: branch instruction at $1F0C jumps back to $1EF4 because branching across page boundary is done in 6502 in two steps (first compute lower address, then higher), CPU does extra memory fetch from $1FF4 (old high address byte, new low address). This can trigger unwanted bank switching. Currently there is no way of detecting this. Far calls placed in inline blocks do not work correctly if the inline is used in different bank that it was defined. Local labels can't be accessed across certain language constructs (like far calls). Local labels before and after such construct appear to be in different local namespaces. Code parser can hang on unexpected input characters.","title":"Known Bugs"},{"location":"known-bugs/#_1","text":"Accidential bank switching can occur when branch instruction jumps back from last bank to previous bank. Example: branch instruction at $1F0C jumps back to $1EF4 because branching across page boundary is done in 6502 in two steps (first compute lower address, then higher), CPU does extra memory fetch from $1FF4 (old high address byte, new low address). This can trigger unwanted bank switching. Currently there is no way of detecting this. Far calls placed in inline blocks do not work correctly if the inline is used in different bank that it was defined. Local labels can't be accessed across certain language constructs (like far calls). Local labels before and after such construct appear to be in different local namespaces. Code parser can hang on unexpected input characters.","title":""},{"location":"projects/","text":"Ataventure by DMA TIM1T by Cluster & DMA K65 used only for audio Ascend by Cluster & DMA Derivative 2600 by Cluster & DMA","title":"Projects"},{"location":"projects/#_1","text":"Ataventure by DMA TIM1T by Cluster & DMA K65 used only for audio Ascend by Cluster & DMA Derivative 2600 by Cluster & DMA","title":""},{"location":"syntax/","text":"Comments K65 uses C -like comments. // this is a line comment /* this is a block comment */ Variable declaration Variables in K65 are names given to chosen memory addresses. Examples of variable declaration: var foo=0x80 // declares 'foo' at address 0x80 var foo2 // declares 'foo2' at address 0x81 (next after previous var) var foo3, foo4 // multiple declarations per line allowed var bar[10], bar2[10] // [] specifies variable size in bytes (address increment for next var) var bar3 ? // adding '?' at the end of var declaration makes compiler print var addresses Constant declaration The best way of defining constants is using the evaluator . Constants defined this way can be changed at any moment during compilation. Constants can be any value of floating point type. When used within 6502 instruction, they are converted to single byte by rounding to nearest integer and AND -ing with 0xFF (this way negative values are represented in U2 form). Examples: [ // square brace starts evaluator expression MY_CONSTANT = 5, // define constants SOME_NUMBER = 0x13 ] // end of evaluator expression Bank selection While default bank can be chosen in file list for each file, a file can span across multiple banks. Active bank can be changed at any point in the file. Example: bank my_bank // from now on all code and data will go to 'my_bank' Data block definition Data blocks are defined using data keyword. Defining data block at the same time defines a label to its first element, so the block is accessibl using simple indexing, like MyData,x . Datablocks can have optional alignment or no-page-crossing restrictions enabled. Examples: data MyData { align 16 // align to 16 byte boundary 1 2 3 4 5 6 7 8 // data bytes folow } data MyData2 { align 256 + 8 // align to 8 bytes after page boundary (lower address byte will be 0x08) 1 2 3 4 5 6 7 8 // data bytes folow } data MyData3 { nocross // the data will fit completely inside single page, but can be at any offset within it 1 2 3 4 5 6 7 8 // data bytes folow } Compile-time Evaluator The K65 compiler has embedded evaluator that always executes at compile-time. The evaluator can perform arbitrary math operations which results are inlined in the final code as immediates. The evaluator can also set and use global compiler constants. The evaluator is explained in detail on K65 Evaluator page. Code sections Executable code in K65 compiler is specified in sections. There currently supported types of code sections are: main This function being program entry point. main { a=0 // set accumulator to 0 {} always // loop forever } func User defined function, that can be called from the code. func inc_x { x++ // increments X register and returns } // RTS is added automatically naked Just like func , but no RTS is added automatically at the end. naked inc_x_twice { x++ // increments X register goto inc_x // jump to previously defined inc_x (saves stack) } // no RTS here; make sure function never reaches here inline User defined macro that is inlined in the code when used. inline inc_y { y++ } Functions and inlines are used simply by specifying their names, which places JSR opcode or inlines the code. Function and inline calls do not pass any parameters. Any potential parameter and return value handling must be handled explicitly by the programmer using either registers, stack or predetermined memory locations. func test { inc_x // this will use JSR instruction to call 'inc_x' defined earlier inc_y // this will inline the 'inc_y' inline - note that it will not add any overhead compared to simple 'y++' } Far calls Functions can also be called with far prefix to mark that the target function is in another bank, than the current one. The bankswitching mechanism used is defined by the linker. Inlines do not use far prefix, because the code is simply inlined. NOTE : if far call is used within inline make sure to use such inline with care - inlining such inline in another bank will copy the inline code directly, which will usually result in improper bankswitching and program crash. func test2_in_different_bank { far inc_x } This page is still under construction - much of the infrmation is still to be filled","title":"Syntax"},{"location":"syntax/#_1","text":"","title":""},{"location":"syntax/#comments","text":"K65 uses C -like comments. // this is a line comment /* this is a block comment */","title":"Comments"},{"location":"syntax/#variable-declaration","text":"Variables in K65 are names given to chosen memory addresses. Examples of variable declaration: var foo=0x80 // declares 'foo' at address 0x80 var foo2 // declares 'foo2' at address 0x81 (next after previous var) var foo3, foo4 // multiple declarations per line allowed var bar[10], bar2[10] // [] specifies variable size in bytes (address increment for next var) var bar3 ? // adding '?' at the end of var declaration makes compiler print var addresses","title":"Variable declaration"},{"location":"syntax/#constant-declaration","text":"The best way of defining constants is using the evaluator . Constants defined this way can be changed at any moment during compilation. Constants can be any value of floating point type. When used within 6502 instruction, they are converted to single byte by rounding to nearest integer and AND -ing with 0xFF (this way negative values are represented in U2 form). Examples: [ // square brace starts evaluator expression MY_CONSTANT = 5, // define constants SOME_NUMBER = 0x13 ] // end of evaluator expression","title":"Constant declaration"},{"location":"syntax/#bank-selection","text":"While default bank can be chosen in file list for each file, a file can span across multiple banks. Active bank can be changed at any point in the file. Example: bank my_bank // from now on all code and data will go to 'my_bank'","title":"Bank selection"},{"location":"syntax/#data-block-definition","text":"Data blocks are defined using data keyword. Defining data block at the same time defines a label to its first element, so the block is accessibl using simple indexing, like MyData,x . Datablocks can have optional alignment or no-page-crossing restrictions enabled. Examples: data MyData { align 16 // align to 16 byte boundary 1 2 3 4 5 6 7 8 // data bytes folow } data MyData2 { align 256 + 8 // align to 8 bytes after page boundary (lower address byte will be 0x08) 1 2 3 4 5 6 7 8 // data bytes folow } data MyData3 { nocross // the data will fit completely inside single page, but can be at any offset within it 1 2 3 4 5 6 7 8 // data bytes folow }","title":"Data block definition"},{"location":"syntax/#compile-time-evaluator","text":"The K65 compiler has embedded evaluator that always executes at compile-time. The evaluator can perform arbitrary math operations which results are inlined in the final code as immediates. The evaluator can also set and use global compiler constants. The evaluator is explained in detail on K65 Evaluator page.","title":"Compile-time Evaluator"},{"location":"syntax/#code-sections","text":"Executable code in K65 compiler is specified in sections. There currently supported types of code sections are:","title":"Code sections"},{"location":"syntax/#main","text":"This function being program entry point. main { a=0 // set accumulator to 0 {} always // loop forever }","title":"main"},{"location":"syntax/#func","text":"User defined function, that can be called from the code. func inc_x { x++ // increments X register and returns } // RTS is added automatically","title":"func"},{"location":"syntax/#naked","text":"Just like func , but no RTS is added automatically at the end. naked inc_x_twice { x++ // increments X register goto inc_x // jump to previously defined inc_x (saves stack) } // no RTS here; make sure function never reaches here","title":"naked"},{"location":"syntax/#inline","text":"User defined macro that is inlined in the code when used. inline inc_y { y++ } Functions and inlines are used simply by specifying their names, which places JSR opcode or inlines the code. Function and inline calls do not pass any parameters. Any potential parameter and return value handling must be handled explicitly by the programmer using either registers, stack or predetermined memory locations. func test { inc_x // this will use JSR instruction to call 'inc_x' defined earlier inc_y // this will inline the 'inc_y' inline - note that it will not add any overhead compared to simple 'y++' }","title":"inline"},{"location":"syntax/#far-calls","text":"Functions can also be called with far prefix to mark that the target function is in another bank, than the current one. The bankswitching mechanism used is defined by the linker. Inlines do not use far prefix, because the code is simply inlined. NOTE : if far call is used within inline make sure to use such inline with care - inlining such inline in another bank will copy the inline code directly, which will usually result in improper bankswitching and program crash. func test2_in_different_bank { far inc_x } This page is still under construction - much of the infrmation is still to be filled","title":"Far calls"},{"location":"todo/","text":"Here is my current list of things still to be done in K65 compiler. Simple signal errors on undefined character in string #if's within data #if's within code support for binary numbers report error when section names are reused (e.g. in inline section) correct support of <flag>+? and <flag>-? branch operators >={...}>= loops and similar support for negative eval results extend binary operations in eval change ^ operator to bitwise xor in eval 256-byte data section should work with nocross add fixed address option for sections add option to place sections in multiple banks fix lexer hanging on invalid input Medium support for custom palettes mark section as referenced if ANY of its labels are referenced array support option to force full addressing with zeropage addresses include raw binary data from file extend computation on labels (compute Label1 - Label2 + Offset ) switch to external image loader library (OpenIL?) Hard/large macros pure assembly sections alternate bankswitching schemes alternate platforms per-instruction bank bits linker refactoring generalized linker bank blocks jumping bank checking when getting addresses option to override ORG and RORG execution address lazy code sections target files and names .bin .lst .sym in config file make LST files compatible with DASM/Stella language reference document","title":"To Do"},{"location":"todo/#_1","text":"Here is my current list of things still to be done in K65 compiler.","title":""},{"location":"todo/#simple","text":"signal errors on undefined character in string #if's within data #if's within code support for binary numbers report error when section names are reused (e.g. in inline section) correct support of <flag>+? and <flag>-? branch operators >={...}>= loops and similar support for negative eval results extend binary operations in eval change ^ operator to bitwise xor in eval 256-byte data section should work with nocross add fixed address option for sections add option to place sections in multiple banks fix lexer hanging on invalid input","title":"Simple"},{"location":"todo/#medium","text":"support for custom palettes mark section as referenced if ANY of its labels are referenced array support option to force full addressing with zeropage addresses include raw binary data from file extend computation on labels (compute Label1 - Label2 + Offset ) switch to external image loader library (OpenIL?)","title":"Medium"},{"location":"todo/#hardlarge","text":"macros pure assembly sections alternate bankswitching schemes alternate platforms per-instruction bank bits linker refactoring generalized linker bank blocks jumping bank checking when getting addresses option to override ORG and RORG execution address lazy code sections target files and names .bin .lst .sym in config file make LST files compatible with DASM/Stella language reference document","title":"Hard/large"}]}