{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to K65 K65 is a compiler for 6502 CPU architecture. At this moment it supports Atari 8-bit (400/800/XL/XE), Commodore 64 and Atari 2600 as target platforms. Language Support Visual Studio Code Syntax Highlighting Extension Dowloads Current release K65 SDK version 0.2.1 Older releases K65 SDK version 0.2.0 K65 SDK version 0.1.2 Changelog SDK 0.2.1 New example Atari 2600 demo sources included: Ascend and Derivative 2600 by Cluster & DMA Linker now reports final section sizes again Minor compiler bugfixes FIX : Atari XL/XE and C64 systems sometimes exported truncated images This documentation is currently being built.","title":"Home"},{"location":"#welcome-to-k65","text":"K65 is a compiler for 6502 CPU architecture. At this moment it supports Atari 8-bit (400/800/XL/XE), Commodore 64 and Atari 2600 as target platforms.","title":"Welcome to K65"},{"location":"#language-support","text":"","title":"Language Support"},{"location":"#visual-studio-code","text":"Syntax Highlighting Extension","title":"Visual Studio Code"},{"location":"#dowloads","text":"","title":"Dowloads"},{"location":"#current-release","text":"K65 SDK version 0.2.1","title":"Current release"},{"location":"#older-releases","text":"K65 SDK version 0.2.0 K65 SDK version 0.1.2","title":"Older releases"},{"location":"#changelog","text":"","title":"Changelog"},{"location":"#sdk-021","text":"New example Atari 2600 demo sources included: Ascend and Derivative 2600 by Cluster & DMA Linker now reports final section sizes again Minor compiler bugfixes FIX : Atari XL/XE and C64 systems sometimes exported truncated images This documentation is currently being built.","title":"SDK 0.2.1"},{"location":"evaluator/","text":"Evaluator in K65 is compile-time executed expression language very similar to C/C++ expressions. Introduction In every place where the compiler expects a single number, you can invoke the evaluator by simply using square brackets. data NumberFour { [2+2] } The evaluator can be also invoked freely outside any section body, e.g. to set variables: [ FOUR = 4 ] which can be later used freely as compiler constants and within further evaluator expressions: data FourFiveSix { FOUR // value of variable FOUR defined earlier [FIVE = FOUR+1] // defines variable FIVE and returns its value [FIVE+1] // uses recently set FIVE value } Operators Available operators and their precedence levels are similar to operators in C and C++ , operators are sorted by precedence from highest to lowest: Precedence 2 Associativity: left-to-right Operator Description ++ -- () [] . suffix incremen suffix decrement function call array subscripting single argument function call Precedence 3 Associativity: right-to-left Operator Description ++ -- + - ! ~ prefix increment prefix decrement unary plus unary minus logical NOT bitwise NOT (One's Complement) Precedence 5 Associativity: left-to-right Operator Description * / % multiplication division modulo (remainder) Precedence 6 Associativity: left-to-right Operator Description + - addition subtraction Precedence 7 Associativity: left-to-right Operator Description << >> bitwise left shift bitwise right shift Precedence 8 Associativity: left-to-right Operator Description < <= > >= ?> ?< less than less than or equal to greater than greater than or equal to select greater value (maximum) select smaller value (minimum) Precedence 9 Associativity: left-to-right Operator Description == != equal to not equal to Precedence 10 Associativity: left-to-right Operator Descriptiont & bitwise AND Precedence 11 Associativity: left-to-right Operator Description ^ bitwise XOR (exclusive or) Precedence 12 Associativity: left-to-right Operator Description | bitwise OR (inclusive or) Precedence 13 Associativity: left-to-right Operator Description && logical AND Precedence 14 Associativity: left-to-right Operator Description || logical OR Precedence 15 Associativity: right-to-left Operator Description ?: lternary conditional Precedence 16 Associativity: right-to-left Operator Description = += -= *= /= %= <<= >>= &= ^= |= direct assignment assignment by sum assignment by difference assignment by product assignment by quotient assignment by remainder assignment by bitwise left shift assignment by bitwise right shift assignment by bitwise AND assignment by bitwise XOR assignment by bitwise OR Precedence 18 Associativity: left-to-right Operator Description , expression list (executes in sequence, returns value of the last) Functions acos( x ) Arcus cosinus addbyte( sec, b ) Add byte b to section sec asin( x ) Arcus sinus ceil( x ) Round up to nearest integer clamp( x, min, max ) Clamp x to range min to max color( r, g, b ) Return palette index for nearest color to color (r,g,b) color( x ) Return palette index for nearest color specified in format 0xRRGGBB cos( x ) Cosinus error( err ) Print error message err ane terminate compilation floor( x ) Round down to nearest integer frac( x ) Get fractional part ( x-floor(x) ) index( tab, x ) 1-dimensional indexing operator ( same as tab[x] ) index( tab, x, y ) 2-dimensional indexing operator ( same as tab[x,y] ) max( a, b ) Maximum min( a, b ) Minimum pow( x, y ) Power function print( msg ) Print message msg rnd( ) Random value 0 <= x < 1 round( x ) Round to nearest integer sin( x ) Sinus size( sec ) Current size of section sec sqrt( x ) Square root","title":"Evaluator"},{"location":"evaluator/#_1","text":"Evaluator in K65 is compile-time executed expression language very similar to C/C++ expressions.","title":""},{"location":"evaluator/#introduction","text":"In every place where the compiler expects a single number, you can invoke the evaluator by simply using square brackets. data NumberFour { [2+2] } The evaluator can be also invoked freely outside any section body, e.g. to set variables: [ FOUR = 4 ] which can be later used freely as compiler constants and within further evaluator expressions: data FourFiveSix { FOUR // value of variable FOUR defined earlier [FIVE = FOUR+1] // defines variable FIVE and returns its value [FIVE+1] // uses recently set FIVE value }","title":"Introduction"},{"location":"evaluator/#operators","text":"Available operators and their precedence levels are similar to operators in C and C++ , operators are sorted by precedence from highest to lowest:","title":"Operators"},{"location":"evaluator/#precedence-2","text":"Associativity: left-to-right Operator Description ++ -- () [] . suffix incremen suffix decrement function call array subscripting single argument function call","title":"Precedence 2"},{"location":"evaluator/#precedence-3","text":"Associativity: right-to-left Operator Description ++ -- + - ! ~ prefix increment prefix decrement unary plus unary minus logical NOT bitwise NOT (One's Complement)","title":"Precedence 3"},{"location":"evaluator/#precedence-5","text":"Associativity: left-to-right Operator Description * / % multiplication division modulo (remainder)","title":"Precedence 5"},{"location":"evaluator/#precedence-6","text":"Associativity: left-to-right Operator Description + - addition subtraction","title":"Precedence 6"},{"location":"evaluator/#precedence-7","text":"Associativity: left-to-right Operator Description << >> bitwise left shift bitwise right shift","title":"Precedence 7"},{"location":"evaluator/#precedence-8","text":"Associativity: left-to-right Operator Description < <= > >= ?> ?< less than less than or equal to greater than greater than or equal to select greater value (maximum) select smaller value (minimum)","title":"Precedence 8"},{"location":"evaluator/#precedence-9","text":"Associativity: left-to-right Operator Description == != equal to not equal to","title":"Precedence 9"},{"location":"evaluator/#precedence-10","text":"Associativity: left-to-right Operator Descriptiont & bitwise AND","title":"Precedence 10"},{"location":"evaluator/#precedence-11","text":"Associativity: left-to-right Operator Description ^ bitwise XOR (exclusive or)","title":"Precedence 11"},{"location":"evaluator/#precedence-12","text":"Associativity: left-to-right Operator Description | bitwise OR (inclusive or)","title":"Precedence 12"},{"location":"evaluator/#precedence-13","text":"Associativity: left-to-right Operator Description && logical AND","title":"Precedence 13"},{"location":"evaluator/#precedence-14","text":"Associativity: left-to-right Operator Description || logical OR","title":"Precedence 14"},{"location":"evaluator/#precedence-15","text":"Associativity: right-to-left Operator Description ?: lternary conditional","title":"Precedence 15"},{"location":"evaluator/#precedence-16","text":"Associativity: right-to-left Operator Description = += -= *= /= %= <<= >>= &= ^= |= direct assignment assignment by sum assignment by difference assignment by product assignment by quotient assignment by remainder assignment by bitwise left shift assignment by bitwise right shift assignment by bitwise AND assignment by bitwise XOR assignment by bitwise OR","title":"Precedence 16"},{"location":"evaluator/#precedence-18","text":"Associativity: left-to-right Operator Description , expression list (executes in sequence, returns value of the last)","title":"Precedence 18"},{"location":"evaluator/#functions","text":"","title":"Functions"},{"location":"evaluator/#acos-x","text":"Arcus cosinus","title":"acos( x )"},{"location":"evaluator/#addbyte-sec-b","text":"Add byte b to section sec","title":"addbyte( sec, b )"},{"location":"evaluator/#asin-x","text":"Arcus sinus","title":"asin( x )"},{"location":"evaluator/#ceil-x","text":"Round up to nearest integer","title":"ceil( x )"},{"location":"evaluator/#clamp-x-min-max","text":"Clamp x to range min to max","title":"clamp( x, min, max )"},{"location":"evaluator/#color-r-g-b","text":"Return palette index for nearest color to color (r,g,b)","title":"color( r, g, b )"},{"location":"evaluator/#color-x","text":"Return palette index for nearest color specified in format 0xRRGGBB","title":"color( x )"},{"location":"evaluator/#cos-x","text":"Cosinus","title":"cos( x )"},{"location":"evaluator/#error-err","text":"Print error message err ane terminate compilation","title":"error( err )"},{"location":"evaluator/#floor-x","text":"Round down to nearest integer","title":"floor( x )"},{"location":"evaluator/#frac-x","text":"Get fractional part ( x-floor(x) )","title":"frac( x )"},{"location":"evaluator/#index-tab-x","text":"1-dimensional indexing operator ( same as tab[x] )","title":"index( tab, x )"},{"location":"evaluator/#index-tab-x-y","text":"2-dimensional indexing operator ( same as tab[x,y] )","title":"index( tab, x, y )"},{"location":"evaluator/#max-a-b","text":"Maximum","title":"max( a, b )"},{"location":"evaluator/#min-a-b","text":"Minimum","title":"min( a, b )"},{"location":"evaluator/#pow-x-y","text":"Power function","title":"pow( x, y )"},{"location":"evaluator/#print-msg","text":"Print message msg","title":"print( msg )"},{"location":"evaluator/#rnd","text":"Random value 0 <= x < 1","title":"rnd( )"},{"location":"evaluator/#round-x","text":"Round to nearest integer","title":"round( x )"},{"location":"evaluator/#sin-x","text":"Sinus","title":"sin( x )"},{"location":"evaluator/#size-sec","text":"Current size of section sec","title":"size( sec )"},{"location":"evaluator/#sqrt-x","text":"Square root","title":"sqrt( x )"},{"location":"examples/","text":"Scripts Project example files main.k65proj -system AtariXL -lowAddr 0x2000 ../../include/defs.k65 main main.k65 main -o main.xex -link !atari800 main.xex make K65=${K65_HOME}/bin/k65 all: main clean main: $(K65) @main.k65proj clean: rm main.gmap main.lst main.sym Atari 800 XL Rainbow main { { COLPF2=a=VCOUNT WSYNC=a } always } Starfield var PCOLR0 = 0x02C0 data stars { align 256 for x=0..255 eval [ rnd() & 255 ] } data speed { align 256 for x=0..255 eval [ (rnd() & 3) + 1 ] } main { PCOLR0=a=14 GRAFM=a { a=0 { a?VCOUNT } != x=0 { WSYNC=a HPOSM0=a=stars,x a=stars,x a+speed,x stars,x=a x++ } != } always } DLI example var VDSLST = 0x0200 var SDLST = 0x0230 var screen = 0x8000 data displist { nocross 0x70 0x70 0x70 0x42 &<screen &>screen 2 2 2 0xF0 2 2 2 2 0x41 &<displist &>displist } naked dli { a!! COLPF2=a=0xDE WSYNC=a a?? return_i } main { SDLST=a=&<displist SDLST+1=a=&>displist VDSLST=a=&<dli VDSLST+1=a=&>dli NMIEN=a=0xC0 {} always } Flame //------------------------------------------------------------------------------ // Flame by koalka/bbsl/karzelki //------------------------------------------------------------------------------ var RTCLOK = 0x0014 var SDLSTL = 0x0230 var SDLSTH = 0x0231 var SDMCTL = 0x022F var GPRIOR = 0x026F var COLOR4 = 0x02C8 var CHBAS = 0x02F4 var fonts = 0x6000 var screen = 0x6400 data dl { nocross 0x42 &<screen &>screen for x=0..19 eval [2] 0x41 &<dl &>dl } inline pause { a=RTCLOK { a?RTCLOK } == } main { COLOR4=a=0x20 CHBAS=a=&>fonts SDLSTL=a=&<dl SDLSTH=a=&>dl GPRIOR=a=0x40 SDMCTL=a=0x21 a=0 x=a y=a { screen,x=a screen+0x100,x=a screen+0x200,x=a screen+0x300,x=a x++ } != { { fonts,x=a x++ y++ y?8 } != y=0 c- a+0x11 } < { { a=screen-1,y c- a+screen,y a+screen+1,y a+screen+32,y a>> a>> screen-31,y=a a=screen+0xFF,y c- a+screen+0x100,y a+screen+0x101,y a+screen+0x120,y a>> a>> screen+0xE1,y=a a=screen+0x1FF,y c- a+screen+0x200,y a+screen+0x201,y a+screen+0x220,y a>> a>> screen+0x1E1,y=a y++ } != COLBK=a=10 pause x=0x1F { a=RANDOM a&15 screen+0x2E0,x=a x-- } >=0 } always } Mode 9++/10++ // Mode 9++ GPRIOR=a=0x40 // Mode 10++ GPRIOR=a=0x81 var VDSLST=0x0200, SDLSTL=0x0230, SDMCTL=0x022F, GPRIOR=0x026F var screen = 0xF000 data dl { nocross 0x90 0x6F &<screen &>screen for x=1..58 eval [ x&1 ? 0x8F : 0x2F ] 0x41 &<dl &>dl } naked dli { a!! WSYNC=a VSCROL=a=13 VSCROL=a=3 a?? return_i } main { VDSLST=a=&<dli VDSLST+1=a=&>dli SDLSTL=a=&<dl SDLSTL+1=a=&>dl SDMCTL=a=0x22 GPRIOR=a=0x40 NMIEN=a=0xC0 {} always } Quatari landscape //------------------------------------------------------------------------------ // This is a part of Quatari 256B intro // https://demozoo.org/productions/280623 // for 8bit AtariXL, OS Rev 2 //------------------------------------------------------------------------------ var CURSOR_Y = 0x54 var CURSOR_X = 0x55 var PREV_Y = 0x5A var PREV_X = 0x5B var iter = 0x80 var COLOR4 = 0x02C8 var COLOR = 0x02FB var RND = 0xD20A var openmode = 0xEF9C var drawto = 0xF9C2 data colorHeight { 170 150 144 144 122 122 110 110 94 94 86 86 82 80 } main { a=9 call openmode COLOR4=a=0xB0 iter=a=79 { CURSOR_X=a=iter PREV_X=a PREV_Y=a=1 COLOR=a=13 { x=COLOR CURSOR_Y=a=colorHeight,x a=RND <0 { colorHeight,x++ } a=RND <0 { colorHeight,x-- } call drawto COLOR-- } >=0 iter-- } != {} always } Screensaver var LNFLG = 0, RTCLOK = 0x14, tmp = 0x80 main { a=0x3f tmp=a a=0xff x=0xf { HPOSP0,x=a x-- } >=0 { .start: WSYNC=a a=LNFLG LNFLG++ a^0x20 HPOSP0=a a^tmp HPOSP1=a a=VCOUNT COLPM0=a a^0xff COLPM1=a a=VCOUNT a?0x40 < goto .jump LNFLG-- LNFLG-- .jump: a=VCOUNT != goto .start a=RTCLOK LNFLG=a a&0x7f != goto .start tmp++ } always }","title":"Examples"},{"location":"examples/#_1","text":"","title":""},{"location":"examples/#scripts","text":"","title":"Scripts"},{"location":"examples/#project-example-files","text":"main.k65proj -system AtariXL -lowAddr 0x2000 ../../include/defs.k65 main main.k65 main -o main.xex -link !atari800 main.xex make K65=${K65_HOME}/bin/k65 all: main clean main: $(K65) @main.k65proj clean: rm main.gmap main.lst main.sym","title":"Project example files"},{"location":"examples/#atari-800-xl","text":"","title":"Atari 800 XL"},{"location":"examples/#rainbow","text":"main { { COLPF2=a=VCOUNT WSYNC=a } always }","title":"Rainbow"},{"location":"examples/#starfield","text":"var PCOLR0 = 0x02C0 data stars { align 256 for x=0..255 eval [ rnd() & 255 ] } data speed { align 256 for x=0..255 eval [ (rnd() & 3) + 1 ] } main { PCOLR0=a=14 GRAFM=a { a=0 { a?VCOUNT } != x=0 { WSYNC=a HPOSM0=a=stars,x a=stars,x a+speed,x stars,x=a x++ } != } always }","title":"Starfield"},{"location":"examples/#dli-example","text":"var VDSLST = 0x0200 var SDLST = 0x0230 var screen = 0x8000 data displist { nocross 0x70 0x70 0x70 0x42 &<screen &>screen 2 2 2 0xF0 2 2 2 2 0x41 &<displist &>displist } naked dli { a!! COLPF2=a=0xDE WSYNC=a a?? return_i } main { SDLST=a=&<displist SDLST+1=a=&>displist VDSLST=a=&<dli VDSLST+1=a=&>dli NMIEN=a=0xC0 {} always }","title":"DLI example"},{"location":"examples/#flame","text":"//------------------------------------------------------------------------------ // Flame by koalka/bbsl/karzelki //------------------------------------------------------------------------------ var RTCLOK = 0x0014 var SDLSTL = 0x0230 var SDLSTH = 0x0231 var SDMCTL = 0x022F var GPRIOR = 0x026F var COLOR4 = 0x02C8 var CHBAS = 0x02F4 var fonts = 0x6000 var screen = 0x6400 data dl { nocross 0x42 &<screen &>screen for x=0..19 eval [2] 0x41 &<dl &>dl } inline pause { a=RTCLOK { a?RTCLOK } == } main { COLOR4=a=0x20 CHBAS=a=&>fonts SDLSTL=a=&<dl SDLSTH=a=&>dl GPRIOR=a=0x40 SDMCTL=a=0x21 a=0 x=a y=a { screen,x=a screen+0x100,x=a screen+0x200,x=a screen+0x300,x=a x++ } != { { fonts,x=a x++ y++ y?8 } != y=0 c- a+0x11 } < { { a=screen-1,y c- a+screen,y a+screen+1,y a+screen+32,y a>> a>> screen-31,y=a a=screen+0xFF,y c- a+screen+0x100,y a+screen+0x101,y a+screen+0x120,y a>> a>> screen+0xE1,y=a a=screen+0x1FF,y c- a+screen+0x200,y a+screen+0x201,y a+screen+0x220,y a>> a>> screen+0x1E1,y=a y++ } != COLBK=a=10 pause x=0x1F { a=RANDOM a&15 screen+0x2E0,x=a x-- } >=0 } always }","title":"Flame"},{"location":"examples/#mode-910","text":"// Mode 9++ GPRIOR=a=0x40 // Mode 10++ GPRIOR=a=0x81 var VDSLST=0x0200, SDLSTL=0x0230, SDMCTL=0x022F, GPRIOR=0x026F var screen = 0xF000 data dl { nocross 0x90 0x6F &<screen &>screen for x=1..58 eval [ x&1 ? 0x8F : 0x2F ] 0x41 &<dl &>dl } naked dli { a!! WSYNC=a VSCROL=a=13 VSCROL=a=3 a?? return_i } main { VDSLST=a=&<dli VDSLST+1=a=&>dli SDLSTL=a=&<dl SDLSTL+1=a=&>dl SDMCTL=a=0x22 GPRIOR=a=0x40 NMIEN=a=0xC0 {} always }","title":"Mode 9++/10++"},{"location":"examples/#quatari-landscape","text":"//------------------------------------------------------------------------------ // This is a part of Quatari 256B intro // https://demozoo.org/productions/280623 // for 8bit AtariXL, OS Rev 2 //------------------------------------------------------------------------------ var CURSOR_Y = 0x54 var CURSOR_X = 0x55 var PREV_Y = 0x5A var PREV_X = 0x5B var iter = 0x80 var COLOR4 = 0x02C8 var COLOR = 0x02FB var RND = 0xD20A var openmode = 0xEF9C var drawto = 0xF9C2 data colorHeight { 170 150 144 144 122 122 110 110 94 94 86 86 82 80 } main { a=9 call openmode COLOR4=a=0xB0 iter=a=79 { CURSOR_X=a=iter PREV_X=a PREV_Y=a=1 COLOR=a=13 { x=COLOR CURSOR_Y=a=colorHeight,x a=RND <0 { colorHeight,x++ } a=RND <0 { colorHeight,x-- } call drawto COLOR-- } >=0 iter-- } != {} always }","title":"Quatari landscape"},{"location":"examples/#screensaver","text":"var LNFLG = 0, RTCLOK = 0x14, tmp = 0x80 main { a=0x3f tmp=a a=0xff x=0xf { HPOSP0,x=a x-- } >=0 { .start: WSYNC=a a=LNFLG LNFLG++ a^0x20 HPOSP0=a a^tmp HPOSP1=a a=VCOUNT COLPM0=a a^0xff COLPM1=a a=VCOUNT a?0x40 < goto .jump LNFLG-- LNFLG-- .jump: a=VCOUNT != goto .start a=RTCLOK LNFLG=a a&0x7f != goto .start tmp++ } always }","title":"Screensaver"},{"location":"instructions/","text":"Address Modes A accumulator OPC A operand is AC (implied single byte instruction) abs absolute OPC $LLHH operand is address $HHLL * abs,X absolute, X-indexed OPC $LLHH,X operand is address; effective address is address incremented by X with carry ** abs,Y absolute, Y-indexed OPC $LLHH,Y operand is address; effective address is address incremented by Y with carry ** # immediate OPC #$BB operand is byte BB impl implied OPC operand implied ind indirect OPC ($LLHH) operand is address; effective address is contents of word at address: C.w($HHLL) X,ind X-indexed, indirect OPC ($LL,X) operand is zeropage address; effective address is word in (LL + X, LL + X + 1), inc. without carry: C.w($00LL + X) ind,Y indirect, Y-indexed OPC ($LL),Y operand is zeropage address; effective address is word in (LL, LL + 1) incremented by Y with carry: C.w($00LL) + Y rel relative OPC $BB branch target is PC + signed offset BB *** zpg zeropage OPC $LL operand is zeropage address (hi-byte is zero, address = $00LL ) zpg,X zeropage, X-indexed OPC $LL,X operand is zeropage address; effective address is address incremented by X without carry ** zpg,Y zeropage, Y-indexed OPC $LL,Y operand is zeropage address; effective address is address incremented by Y without carry ** * 16-bit address words are little endian , lo(w)-byte first, followed by the hi(gh)-byte. An assembler will use a human readable, big-endian notation as in $HHLL . ** The available 16-bit address space is conceived as consisting of pages of 256 bytes each, with address hi-bytes represententing the page index. An increment with carry may affect the hi-byte and may thus result in a crossing of page boundaries, adding an extra cycle to the execution. Increments without carry do not affect the hi-byte of an address and no page transitions do occur. Generally, increments of 16-bit addresses include a carry, increments of zeropage addresses don't. Notably this is not related in any way to the state of the carry bit of the accumulator. *** Branch offsets are signed 8-bit values, -128 ... +127 , negative offsets in two's complement. Page transitions may occur and add an extra cycle to the exucution. Registers PC program counter (16 bit) AC accumulator (8 bit) X X register (8 bit) Y Y register (8 bit) SR status register NV-BDIZC (8 bit) SP stack pointer (8 bit) SR Flags NV-BDIZC bit 7 to bit 0 N .... Negative V .... Overflow - .... ignored B .... Break D .... Decimal (use BCD for arithmetics) I .... Interrupt (IRQ disable) Z .... Zero C .... Carry Processor Stack LIFO , top down, 8 bit range 0x0100 - 0x01FF Bytes, Words, Addressing 8 bit bytes, 16 bit words in lobyte-hibyte representation ( Little-Endian ). 16 bit address range, operands follow instruction codes. Signed values are two's complement, sign in bit 7 (most significant bit). %11111111 = $FF = -1 %10000000 = $80 = -128 %01111111 = $7F = +127 Standard 6502 opcodes K65 compiler supports following 6502 instructions. TBD value means that instruction support is planned, but currently not implemented. ADC AND ASL BCC BCS BEQ BIT BMI BNE BPL BRK BVC BVS CLC CLD CLI CLV CMP CPX CPY DEC DEX DEY EOR INC INX INY JMP JSR LDA LDX LDY LSR NOP ORA PHA PHP PLA PLP ROL ROR RTI RTS SBC SEC SED SEI STA STX STY TAX TAY TSX TXA TXS TYA ADC add with carry Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a+imm a+mem a+mem,x a+mem,y a+(mem,x) a+(mem),y ADC Add Memory to Accumulator with Carry A + M + C -> A, C N Z C I D V + + + - - + addressing assembler opc bytes cyles -------------------------------------------- immidiate ADC #oper 69 2 2 zeropage ADC oper 65 2 3 zeropage,X ADC oper,X 75 2 4 absolute ADC oper 6D 3 4 absolute,X ADC oper,X 7D 3 4* absolute,Y ADC oper,Y 79 3 4* (indirect,X) ADC (oper,X) 61 2 6 (indirect),Y ADC (oper),Y 71 2 5* AND and (with accumulator) Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a&imm a&mem a&mem,x a&mem,y a&(mem,x) a&(mem),y AND AND Memory with Accumulator A AND M -> A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate AND #oper 29 2 2 zeropage AND oper 25 2 3 zeropage,X AND oper,X 35 2 4 absolute AND oper 2D 3 4 absolute,X AND oper,X 3D 3 4* absolute,Y AND oper,Y 39 3 4* (indirect,X) AND (oper,X) 21 2 6 (indirect),Y AND (oper),Y 31 2 5* ASL arithmetic shift left Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a<< mem<< mem,x<< ASL Shift Left One Bit (Memory or Accumulator) C <- [76543210] <- 0 N Z C I D V + + + - - - addressing assembler opc bytes cyles -------------------------------------------- accumulator ASL A 0A 1 2 zeropage ASL oper 06 2 5 zeropage,X ASL oper,X 16 2 6 absolute ASL oper 0E 3 6 absolute,X ASL oper,X 1E 3 7 BCC branch on carry clear >={ ... } < goto label { ... } < c+?{ ... } c-? goto label { ... } c-? BCC Branch on Carry Clear branch on C = 0 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BCC oper 90 2 2** BCS branch on carry set <{ ... } >= goto label { ... } >= c-?{ ... } c+? goto label { ... } c+? BCS Branch on Carry Set branch on C = 1 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BCS oper B0 2 2** BEQ branch on equal (zero set) !={ ... } == goto label { ... } == BEQ Branch on Result Zero branch on Z = 1 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BEQ oper F0 2 2** BIT bit test Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a&?mem BIT Test Bits in Memory with Accumulator bits 7 and 6 of operand are transfered to bit 7 and 6 of SR (N,V); the zeroflag is set to the result of operand AND accumulator. A AND M, M7 -> N, M6 -> V N Z C I D V M7 + - - - M6 addressing assembler opc bytes cyles -------------------------------------------- zeropage BIT oper 24 2 3 absolute BIT oper 2C 3 4 BMI branch on minus (negative set) >=0{ ... } <0 goto label { ... } <0 BMI Branch on Result Minus branch on N = 1 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BMI oper 30 2 2** BNE branch on not equal (zero clear) =={ ... } != goto label { ... } != BNE Branch on Result not Zero branch on Z = 0 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BNE oper D0 2 2** BPL branch on plus (negative clear) <0{ ... } >=0 goto label { ... } >=0 BPL Branch on Result Plus branch on N = 0 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BPL oper 10 2 2** BRK interrupt /* TBD */ BRK Force Break interrupt, N Z C I D V push PC+2, push SR - - - 1 - - addressing assembler opc bytes cyles -------------------------------------------- implied BRK 00 1 7 BVC branch on overflow clear <<={ ... } >>= goto label { ... } >>= BVC Branch on Overflow Clear branch on V = 0 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BVC oper 50 2 2** BVS branch on overflow set >>={ ... } <<= goto label { ... } <<= BVS Branch on Overflow Set branch on V = 1 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BVC oper 70 2 2** CLC clear carry Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) c- CLC Clear Carry Flag 0 -> C N Z C I D V - - 0 - - - addressing assembler opc bytes cyles -------------------------------------------- implied CLC 18 1 2 CLD clear decimal Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) d- CLD Clear Decimal Mode 0 -> D N Z C I D V - - - - 0 - addressing assembler opc bytes cyles -------------------------------------------- implied CLD D8 1 2 CLI clear interrupt disable Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) i- CLI Clear Interrupt Disable Bit 0 -> I N Z C I D V - - - 0 - - addressing assembler opc bytes cyles -------------------------------------------- implied CLI 58 1 2 CLV clear overflow Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) o- CLV Clear Overflow Flag 0 -> V N Z C I D V - - - - - 0 addressing assembler opc bytes cyles -------------------------------------------- implied CLV B8 1 2 CMP compare (with accumulator) Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a?imm a?mem a?mem,x a?mem,y a?(mem,x) a?(mem),y CMP Compare Memory with Accumulator A - M N Z C I D V + + + - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate CMP #oper C9 2 2 zeropage CMP oper C5 2 3 zeropage,X CMP oper,X D5 2 4 absolute CMP oper CD 3 4 absolute,X CMP oper,X DD 3 4* absolute,Y CMP oper,Y D9 3 4* (indirect,X) CMP (oper,X) C1 2 6 (indirect),Y CMP (oper),Y D1 2 5* CPX compare with X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x?imm x?mem CPX Compare Memory and Index X X - M N Z C I D V + + + - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate CPX #oper E0 2 2 zeropage CPX oper E4 2 3 absolute CPX oper EC 3 4 CPY compare with Y Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y?imm y?mem CPY Compare Memory and Index Y Y - M N Z C I D V + + + - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate CPY #oper C0 2 2 zeropage CPY oper C4 2 3 absolute CPY oper CC 3 4 DEC decrement Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem-- mem,x-- DEC Decrement Memory by One M - 1 -> M N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- zeropage DEC oper C6 2 5 zeropage,X DEC oper,X D6 2 6 absolute DEC oper CE 3 6 absolute,X DEC oper,X DE 3 7 DEX decrement X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x-- DEX Decrement Index X by One X - 1 -> X N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied DEC CA 1 2 DEY decrement Y Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y-- DEY Decrement Index Y by One Y - 1 -> Y N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied DEC 88 1 2 EOR exclusive or (with accumulator) Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a^imm a^mem a^mem,x a^mem,y a^(mem,x) a^(mem),y EOR Exclusive-OR Memory with Accumulator A EOR M -> A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate EOR #oper 49 2 2 zeropage EOR oper 45 2 3 zeropage,X EOR oper,X 55 2 4 absolute EOR oper 4D 3 4 absolute,X EOR oper,X 5D 3 4* absolute,Y EOR oper,Y 59 3 4* (indirect,X) EOR (oper,X) 41 2 6 (indirect),Y EOR (oper),Y 51 2 5* INC increment Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem++ mem,x++ INC Increment Memory by One M + 1 -> M N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- zeropage INC oper E6 2 5 zeropage,X INC oper,X F6 2 6 absolute INC oper EE 3 6 absolute,X INC oper,X FE 3 7 INX increment X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x++ INX Increment Index X by One X + 1 -> X N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied INX E8 1 2 INY increment Y Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y++ INY Increment Index Y by One Y + 1 -> Y N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied INY C8 1 2 JMP jump Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) goto mem goto (mem) JMP Jump to New Location (PC+1) -> PCL N Z C I D V (PC+2) -> PCH - - - - - - addressing assembler opc bytes cyles -------------------------------------------- absolute JMP oper 4C 3 3 indirect JMP (oper) 6C 3 5 JSR jump subroutine Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) call mem JSR Jump to New Location Saving Return Address push (PC+2), N Z C I D V (PC+1) -> PCL - - - - - - (PC+2) -> PCH addressing assembler opc bytes cyles -------------------------------------------- absolute JSR oper 20 3 6 LDA load accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a=imm a=mem a=mem,x a=mem,y a=(mem,x) a=(mem),y LDA Load Accumulator with Memory M -> A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate LDA #oper A9 2 2 zeropage LDA oper A5 2 3 zeropage,X LDA oper,X B5 2 4 absolute LDA oper AD 3 4 absolute,X LDA oper,X BD 3 4* absolute,Y LDA oper,Y B9 3 4* (indirect,X) LDA (oper,X) A1 2 6 (indirect),Y LDA (oper),Y B1 2 5* LDX load X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x=imm x=mem x=mem,y LDX Load Index X with Memory M -> X N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate LDX #oper A2 2 2 zeropage LDX oper A6 2 3 zeropage,Y LDX oper,Y B6 2 4 absolute LDX oper AE 3 4 absolute,Y LDX oper,Y BE 3 4* LDY load Y Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y=imm y=mem y=mem,x LDY Load Index Y with Memory M -> Y N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate LDY #oper A0 2 2 zeropage LDY oper A4 2 3 zeropage,X LDY oper,X B4 2 4 absolute LDY oper AC 3 4 absolute,X LDY oper,X BC 3 4* LSR logical shift right Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a>> mem>> mem,x>> LSR Shift One Bit Right (Memory or Accumulator) 0 -> [76543210] -> C N Z C I D V 0 + + - - - addressing assembler opc bytes cyles -------------------------------------------- accumulator LSR A 4A 1 2 zeropage LSR oper 46 2 5 zeropage,X LSR oper,X 56 2 6 absolute LSR oper 4E 3 6 absolute,X LSR oper,X 5E 3 7 NOP no operation * for single NOP *<number> to wait <number> of cycles NOP No Operation --- N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- implied NOP EA 1 2 ORA or with accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a|imm a|mem a|mem,x a|mem,y a|(mem,x) a|(mem),y ORA OR Memory with Accumulator A OR M -> A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate ORA #oper 09 2 2 zeropage ORA oper 05 2 3 zeropage,X ORA oper,X 15 2 4 absolute ORA oper 0D 3 4 absolute,X ORA oper,X 1D 3 4* absolute,Y ORA oper,Y 19 3 4* (indirect,X) ORA (oper,X) 01 2 6 (indirect),Y ORA (oper),Y 11 2 5* PHA push accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a!! PHA Push Accumulator on Stack push A N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- implied PHA 48 1 3 PHP push processor status (SR) Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) flag!! PHP Push Processor Status on Stack push SR N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- implied PHP 08 1 3 PLA pull accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a?? PLA Pull Accumulator from Stack pull A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied PLA 68 1 4 PLP pull processor status (SR) Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) flag?? PLP Pull Processor Status from Stack pull SR N Z C I D V from stack addressing assembler opc bytes cyles -------------------------------------------- implied PLP 28 1 4 ROL rotate left Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a<<< mem<<< mem,x<<< ROL Rotate One Bit Left (Memory or Accumulator) C <- [76543210] <- C N Z C I D V + + + - - - addressing assembler opc bytes cyles -------------------------------------------- accumulator ROL A 2A 1 2 zeropage ROL oper 26 2 5 zeropage,X ROL oper,X 36 2 6 absolute ROL oper 2E 3 6 absolute,X ROL oper,X 3E 3 7 ROR rotate right Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a>>> mem>>> mem,x>>> ROR Rotate One Bit Right (Memory or Accumulator) C -> [76543210] -> C N Z C I D V + + + - - - addressing assembler opc bytes cyles -------------------------------------------- accumulator ROR A 6A 1 2 zeropage ROR oper 66 2 5 zeropage,X ROR oper,X 76 2 6 absolute ROR oper 6E 3 6 absolute,X ROR oper,X 7E 3 7 RTI return from interrupt Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) return_i RTI Return from Interrupt pull SR, pull PC N Z C I D V from stack addressing assembler opc bytes cyles -------------------------------------------- implied RTI 40 1 6 RTS return from subroutine Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) return RTS Return from Subroutine pull PC, PC+1 -> PC N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- implied RTS 60 1 6 SBC subtract with carry Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a-imm a-mem a-mem,x a-mem,y a-(mem,x) a-(mem),y SBC Subtract Memory from Accumulator with Borrow A - M - C -> A N Z C I D V + + + - - + addressing assembler opc bytes cyles -------------------------------------------- immidiate SBC #oper E9 2 2 zeropage SBC oper E5 2 3 zeropage,X SBC oper,X F5 2 4 absolute SBC oper ED 3 4 absolute,X SBC oper,X FD 3 4* absolute,Y SBC oper,Y F9 3 4* (indirect,X) SBC (oper,X) E1 2 6 (indirect),Y SBC (oper),Y F1 2 5* SEC set carry Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) c+ SEC Set Carry Flag 1 -> C N Z C I D V - - 1 - - - addressing assembler opc bytes cyles -------------------------------------------- implied SEC 38 1 2 SED set decimal Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) d+ SED Set Decimal Flag 1 -> D N Z C I D V - - - - 1 - addressing assembler opc bytes cyles -------------------------------------------- implied SED F8 1 2 SEI set interrupt disable Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) i+ SEI Set Interrupt Disable Status 1 -> I N Z C I D V - - - 1 - - addressing assembler opc bytes cyles -------------------------------------------- implied SEI 78 1 2 STA store accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem=a mem,x=a mem,y=a (mem,x)=a (mem),y=a STA Store Accumulator in Memory A -> M N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- zeropage STA oper 85 2 3 zeropage,X STA oper,X 95 2 4 absolute STA oper 8D 3 4 absolute,X STA oper,X 9D 3 5 absolute,Y STA oper,Y 99 3 5 (indirect,X) STA (oper,X) 81 2 6 (indirect),Y STA (oper),Y 91 2 6 STX store X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem=x STX Store Index X in Memory X -> M N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- zeropage STX oper 86 2 3 zeropage,Y STX oper,Y 96 2 4 absolute STX oper 8E 3 4 STY store Y Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem=y STY Sore Index Y in Memory Y -> M N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- zeropage STY oper 84 2 3 zeropage,X STY oper,X 94 2 4 absolute STY oper 8C 3 4 TAX transfer accumulator to X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x=a TAX Transfer Accumulator to Index X A -> X N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied TAX AA 1 2 TAY transfer accumulator to Y Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y=a TAY Transfer Accumulator to Index Y A -> Y N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied TAY A8 1 2 TSX transfer stack pointer to X Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x=s TSX Transfer Stack Pointer to Index X SP -> X N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied TSX BA 1 2 TXA transfer X to accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a=x TXA Transfer Index X to Accumulator X -> A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied TXA 8A 1 2 TXS transfer X to stack pointer Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) s=x TXS Transfer Index X to Stack Register X -> SP N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- implied TXS 9A 1 2 TYA transfer Y to accumulator Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a=y TYA Transfer Index Y to Accumulator Y -> A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied TYA 98 1 2 Note * add 1 to cycles if page boundery is crossed ** add 1 to cycles if branch occurs on same page add 2 to cycles if branch occurs to different page Legend to Flags + .... modified - .... not modified 1 .... set 0 .... cleared M6 .... memory bit 6 M7 .... memory bit 7","title":"Instructions"},{"location":"instructions/#_1","text":"","title":""},{"location":"instructions/#address-modes","text":"A accumulator OPC A operand is AC (implied single byte instruction) abs absolute OPC $LLHH operand is address $HHLL * abs,X absolute, X-indexed OPC $LLHH,X operand is address; effective address is address incremented by X with carry ** abs,Y absolute, Y-indexed OPC $LLHH,Y operand is address; effective address is address incremented by Y with carry ** # immediate OPC #$BB operand is byte BB impl implied OPC operand implied ind indirect OPC ($LLHH) operand is address; effective address is contents of word at address: C.w($HHLL) X,ind X-indexed, indirect OPC ($LL,X) operand is zeropage address; effective address is word in (LL + X, LL + X + 1), inc. without carry: C.w($00LL + X) ind,Y indirect, Y-indexed OPC ($LL),Y operand is zeropage address; effective address is word in (LL, LL + 1) incremented by Y with carry: C.w($00LL) + Y rel relative OPC $BB branch target is PC + signed offset BB *** zpg zeropage OPC $LL operand is zeropage address (hi-byte is zero, address = $00LL ) zpg,X zeropage, X-indexed OPC $LL,X operand is zeropage address; effective address is address incremented by X without carry ** zpg,Y zeropage, Y-indexed OPC $LL,Y operand is zeropage address; effective address is address incremented by Y without carry ** * 16-bit address words are little endian , lo(w)-byte first, followed by the hi(gh)-byte. An assembler will use a human readable, big-endian notation as in $HHLL . ** The available 16-bit address space is conceived as consisting of pages of 256 bytes each, with address hi-bytes represententing the page index. An increment with carry may affect the hi-byte and may thus result in a crossing of page boundaries, adding an extra cycle to the execution. Increments without carry do not affect the hi-byte of an address and no page transitions do occur. Generally, increments of 16-bit addresses include a carry, increments of zeropage addresses don't. Notably this is not related in any way to the state of the carry bit of the accumulator. *** Branch offsets are signed 8-bit values, -128 ... +127 , negative offsets in two's complement. Page transitions may occur and add an extra cycle to the exucution.","title":"Address Modes"},{"location":"instructions/#registers","text":"PC program counter (16 bit) AC accumulator (8 bit) X X register (8 bit) Y Y register (8 bit) SR status register NV-BDIZC (8 bit) SP stack pointer (8 bit)","title":"Registers"},{"location":"instructions/#sr-flags-nv-bdizc","text":"bit 7 to bit 0 N .... Negative V .... Overflow - .... ignored B .... Break D .... Decimal (use BCD for arithmetics) I .... Interrupt (IRQ disable) Z .... Zero C .... Carry","title":"SR Flags NV-BDIZC"},{"location":"instructions/#processor-stack","text":"LIFO , top down, 8 bit range 0x0100 - 0x01FF","title":"Processor Stack"},{"location":"instructions/#bytes-words-addressing","text":"8 bit bytes, 16 bit words in lobyte-hibyte representation ( Little-Endian ). 16 bit address range, operands follow instruction codes. Signed values are two's complement, sign in bit 7 (most significant bit). %11111111 = $FF = -1 %10000000 = $80 = -128 %01111111 = $7F = +127","title":"Bytes, Words, Addressing"},{"location":"instructions/#standard-6502-opcodes","text":"K65 compiler supports following 6502 instructions. TBD value means that instruction support is planned, but currently not implemented. ADC AND ASL BCC BCS BEQ BIT BMI BNE BPL BRK BVC BVS CLC CLD CLI CLV CMP CPX CPY DEC DEX DEY EOR INC INX INY JMP JSR LDA LDX LDY LSR NOP ORA PHA PHP PLA PLP ROL ROR RTI RTS SBC SEC SED SEI STA STX STY TAX TAY TSX TXA TXS TYA","title":"Standard 6502 opcodes"},{"location":"instructions/#adc-add-with-carry","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a+imm a+mem a+mem,x a+mem,y a+(mem,x) a+(mem),y ADC Add Memory to Accumulator with Carry A + M + C -> A, C N Z C I D V + + + - - + addressing assembler opc bytes cyles -------------------------------------------- immidiate ADC #oper 69 2 2 zeropage ADC oper 65 2 3 zeropage,X ADC oper,X 75 2 4 absolute ADC oper 6D 3 4 absolute,X ADC oper,X 7D 3 4* absolute,Y ADC oper,Y 79 3 4* (indirect,X) ADC (oper,X) 61 2 6 (indirect),Y ADC (oper),Y 71 2 5*","title":"ADC add with carry"},{"location":"instructions/#and-and-with-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a&imm a&mem a&mem,x a&mem,y a&(mem,x) a&(mem),y AND AND Memory with Accumulator A AND M -> A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate AND #oper 29 2 2 zeropage AND oper 25 2 3 zeropage,X AND oper,X 35 2 4 absolute AND oper 2D 3 4 absolute,X AND oper,X 3D 3 4* absolute,Y AND oper,Y 39 3 4* (indirect,X) AND (oper,X) 21 2 6 (indirect),Y AND (oper),Y 31 2 5*","title":"AND and (with accumulator)"},{"location":"instructions/#asl-arithmetic-shift-left","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a<< mem<< mem,x<< ASL Shift Left One Bit (Memory or Accumulator) C <- [76543210] <- 0 N Z C I D V + + + - - - addressing assembler opc bytes cyles -------------------------------------------- accumulator ASL A 0A 1 2 zeropage ASL oper 06 2 5 zeropage,X ASL oper,X 16 2 6 absolute ASL oper 0E 3 6 absolute,X ASL oper,X 1E 3 7","title":"ASL arithmetic shift left"},{"location":"instructions/#bcc-branch-on-carry-clear","text":">={ ... } < goto label { ... } < c+?{ ... } c-? goto label { ... } c-? BCC Branch on Carry Clear branch on C = 0 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BCC oper 90 2 2**","title":"BCC branch on carry clear"},{"location":"instructions/#bcs-branch-on-carry-set","text":"<{ ... } >= goto label { ... } >= c-?{ ... } c+? goto label { ... } c+? BCS Branch on Carry Set branch on C = 1 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BCS oper B0 2 2**","title":"BCS branch on carry set"},{"location":"instructions/#beq-branch-on-equal-zero-set","text":"!={ ... } == goto label { ... } == BEQ Branch on Result Zero branch on Z = 1 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BEQ oper F0 2 2**","title":"BEQ branch on equal (zero set)"},{"location":"instructions/#bit-bit-test","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a&?mem BIT Test Bits in Memory with Accumulator bits 7 and 6 of operand are transfered to bit 7 and 6 of SR (N,V); the zeroflag is set to the result of operand AND accumulator. A AND M, M7 -> N, M6 -> V N Z C I D V M7 + - - - M6 addressing assembler opc bytes cyles -------------------------------------------- zeropage BIT oper 24 2 3 absolute BIT oper 2C 3 4","title":"BIT bit test"},{"location":"instructions/#bmi-branch-on-minus-negative-set","text":">=0{ ... } <0 goto label { ... } <0 BMI Branch on Result Minus branch on N = 1 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BMI oper 30 2 2**","title":"BMI branch on minus (negative set)"},{"location":"instructions/#bne-branch-on-not-equal-zero-clear","text":"=={ ... } != goto label { ... } != BNE Branch on Result not Zero branch on Z = 0 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BNE oper D0 2 2**","title":"BNE branch on not equal (zero clear)"},{"location":"instructions/#bpl-branch-on-plus-negative-clear","text":"<0{ ... } >=0 goto label { ... } >=0 BPL Branch on Result Plus branch on N = 0 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BPL oper 10 2 2**","title":"BPL branch on plus (negative clear)"},{"location":"instructions/#brk-interrupt","text":"/* TBD */ BRK Force Break interrupt, N Z C I D V push PC+2, push SR - - - 1 - - addressing assembler opc bytes cyles -------------------------------------------- implied BRK 00 1 7","title":"BRK interrupt"},{"location":"instructions/#bvc-branch-on-overflow-clear","text":"<<={ ... } >>= goto label { ... } >>= BVC Branch on Overflow Clear branch on V = 0 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BVC oper 50 2 2**","title":"BVC branch on overflow clear"},{"location":"instructions/#bvs-branch-on-overflow-set","text":">>={ ... } <<= goto label { ... } <<= BVS Branch on Overflow Set branch on V = 1 N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- relative BVC oper 70 2 2**","title":"BVS branch on overflow set"},{"location":"instructions/#clc-clear-carry","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) c- CLC Clear Carry Flag 0 -> C N Z C I D V - - 0 - - - addressing assembler opc bytes cyles -------------------------------------------- implied CLC 18 1 2","title":"CLC clear carry"},{"location":"instructions/#cld-clear-decimal","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) d- CLD Clear Decimal Mode 0 -> D N Z C I D V - - - - 0 - addressing assembler opc bytes cyles -------------------------------------------- implied CLD D8 1 2","title":"CLD clear decimal"},{"location":"instructions/#cli-clear-interrupt-disable","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) i- CLI Clear Interrupt Disable Bit 0 -> I N Z C I D V - - - 0 - - addressing assembler opc bytes cyles -------------------------------------------- implied CLI 58 1 2","title":"CLI clear interrupt disable"},{"location":"instructions/#clv-clear-overflow","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) o- CLV Clear Overflow Flag 0 -> V N Z C I D V - - - - - 0 addressing assembler opc bytes cyles -------------------------------------------- implied CLV B8 1 2","title":"CLV clear overflow"},{"location":"instructions/#cmp-compare-with-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a?imm a?mem a?mem,x a?mem,y a?(mem,x) a?(mem),y CMP Compare Memory with Accumulator A - M N Z C I D V + + + - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate CMP #oper C9 2 2 zeropage CMP oper C5 2 3 zeropage,X CMP oper,X D5 2 4 absolute CMP oper CD 3 4 absolute,X CMP oper,X DD 3 4* absolute,Y CMP oper,Y D9 3 4* (indirect,X) CMP (oper,X) C1 2 6 (indirect),Y CMP (oper),Y D1 2 5*","title":"CMP compare (with accumulator)"},{"location":"instructions/#cpx-compare-with-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x?imm x?mem CPX Compare Memory and Index X X - M N Z C I D V + + + - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate CPX #oper E0 2 2 zeropage CPX oper E4 2 3 absolute CPX oper EC 3 4","title":"CPX compare with X"},{"location":"instructions/#cpy-compare-with-y","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y?imm y?mem CPY Compare Memory and Index Y Y - M N Z C I D V + + + - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate CPY #oper C0 2 2 zeropage CPY oper C4 2 3 absolute CPY oper CC 3 4","title":"CPY compare with Y"},{"location":"instructions/#dec-decrement","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem-- mem,x-- DEC Decrement Memory by One M - 1 -> M N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- zeropage DEC oper C6 2 5 zeropage,X DEC oper,X D6 2 6 absolute DEC oper CE 3 6 absolute,X DEC oper,X DE 3 7","title":"DEC decrement"},{"location":"instructions/#dex-decrement-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x-- DEX Decrement Index X by One X - 1 -> X N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied DEC CA 1 2","title":"DEX decrement X"},{"location":"instructions/#dey-decrement-y","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y-- DEY Decrement Index Y by One Y - 1 -> Y N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied DEC 88 1 2","title":"DEY decrement Y"},{"location":"instructions/#eor-exclusive-or-with-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a^imm a^mem a^mem,x a^mem,y a^(mem,x) a^(mem),y EOR Exclusive-OR Memory with Accumulator A EOR M -> A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate EOR #oper 49 2 2 zeropage EOR oper 45 2 3 zeropage,X EOR oper,X 55 2 4 absolute EOR oper 4D 3 4 absolute,X EOR oper,X 5D 3 4* absolute,Y EOR oper,Y 59 3 4* (indirect,X) EOR (oper,X) 41 2 6 (indirect),Y EOR (oper),Y 51 2 5*","title":"EOR exclusive or (with accumulator)"},{"location":"instructions/#inc-increment","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem++ mem,x++ INC Increment Memory by One M + 1 -> M N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- zeropage INC oper E6 2 5 zeropage,X INC oper,X F6 2 6 absolute INC oper EE 3 6 absolute,X INC oper,X FE 3 7","title":"INC increment"},{"location":"instructions/#inx-increment-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x++ INX Increment Index X by One X + 1 -> X N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied INX E8 1 2","title":"INX increment X"},{"location":"instructions/#iny-increment-y","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y++ INY Increment Index Y by One Y + 1 -> Y N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied INY C8 1 2","title":"INY increment Y"},{"location":"instructions/#jmp-jump","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) goto mem goto (mem) JMP Jump to New Location (PC+1) -> PCL N Z C I D V (PC+2) -> PCH - - - - - - addressing assembler opc bytes cyles -------------------------------------------- absolute JMP oper 4C 3 3 indirect JMP (oper) 6C 3 5","title":"JMP jump"},{"location":"instructions/#jsr-jump-subroutine","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) call mem JSR Jump to New Location Saving Return Address push (PC+2), N Z C I D V (PC+1) -> PCL - - - - - - (PC+2) -> PCH addressing assembler opc bytes cyles -------------------------------------------- absolute JSR oper 20 3 6","title":"JSR jump subroutine"},{"location":"instructions/#lda-load-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a=imm a=mem a=mem,x a=mem,y a=(mem,x) a=(mem),y LDA Load Accumulator with Memory M -> A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate LDA #oper A9 2 2 zeropage LDA oper A5 2 3 zeropage,X LDA oper,X B5 2 4 absolute LDA oper AD 3 4 absolute,X LDA oper,X BD 3 4* absolute,Y LDA oper,Y B9 3 4* (indirect,X) LDA (oper,X) A1 2 6 (indirect),Y LDA (oper),Y B1 2 5*","title":"LDA load accumulator"},{"location":"instructions/#ldx-load-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x=imm x=mem x=mem,y LDX Load Index X with Memory M -> X N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate LDX #oper A2 2 2 zeropage LDX oper A6 2 3 zeropage,Y LDX oper,Y B6 2 4 absolute LDX oper AE 3 4 absolute,Y LDX oper,Y BE 3 4*","title":"LDX load X"},{"location":"instructions/#ldy-load-y","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y=imm y=mem y=mem,x LDY Load Index Y with Memory M -> Y N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate LDY #oper A0 2 2 zeropage LDY oper A4 2 3 zeropage,X LDY oper,X B4 2 4 absolute LDY oper AC 3 4 absolute,X LDY oper,X BC 3 4*","title":"LDY load Y"},{"location":"instructions/#lsr-logical-shift-right","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a>> mem>> mem,x>> LSR Shift One Bit Right (Memory or Accumulator) 0 -> [76543210] -> C N Z C I D V 0 + + - - - addressing assembler opc bytes cyles -------------------------------------------- accumulator LSR A 4A 1 2 zeropage LSR oper 46 2 5 zeropage,X LSR oper,X 56 2 6 absolute LSR oper 4E 3 6 absolute,X LSR oper,X 5E 3 7","title":"LSR logical shift right"},{"location":"instructions/#nop-no-operation","text":"* for single NOP *<number> to wait <number> of cycles NOP No Operation --- N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- implied NOP EA 1 2","title":"NOP no operation"},{"location":"instructions/#ora-or-with-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a|imm a|mem a|mem,x a|mem,y a|(mem,x) a|(mem),y ORA OR Memory with Accumulator A OR M -> A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immidiate ORA #oper 09 2 2 zeropage ORA oper 05 2 3 zeropage,X ORA oper,X 15 2 4 absolute ORA oper 0D 3 4 absolute,X ORA oper,X 1D 3 4* absolute,Y ORA oper,Y 19 3 4* (indirect,X) ORA (oper,X) 01 2 6 (indirect),Y ORA (oper),Y 11 2 5*","title":"ORA or with accumulator"},{"location":"instructions/#pha-push-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a!! PHA Push Accumulator on Stack push A N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- implied PHA 48 1 3","title":"PHA push accumulator"},{"location":"instructions/#php-push-processor-status-sr","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) flag!! PHP Push Processor Status on Stack push SR N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- implied PHP 08 1 3","title":"PHP push processor status (SR)"},{"location":"instructions/#pla-pull-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a?? PLA Pull Accumulator from Stack pull A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied PLA 68 1 4","title":"PLA pull accumulator"},{"location":"instructions/#plp-pull-processor-status-sr","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) flag?? PLP Pull Processor Status from Stack pull SR N Z C I D V from stack addressing assembler opc bytes cyles -------------------------------------------- implied PLP 28 1 4","title":"PLP pull processor status (SR)"},{"location":"instructions/#rol-rotate-left","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a<<< mem<<< mem,x<<< ROL Rotate One Bit Left (Memory or Accumulator) C <- [76543210] <- C N Z C I D V + + + - - - addressing assembler opc bytes cyles -------------------------------------------- accumulator ROL A 2A 1 2 zeropage ROL oper 26 2 5 zeropage,X ROL oper,X 36 2 6 absolute ROL oper 2E 3 6 absolute,X ROL oper,X 3E 3 7","title":"ROL rotate left"},{"location":"instructions/#ror-rotate-right","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a>>> mem>>> mem,x>>> ROR Rotate One Bit Right (Memory or Accumulator) C -> [76543210] -> C N Z C I D V + + + - - - addressing assembler opc bytes cyles -------------------------------------------- accumulator ROR A 6A 1 2 zeropage ROR oper 66 2 5 zeropage,X ROR oper,X 76 2 6 absolute ROR oper 6E 3 6 absolute,X ROR oper,X 7E 3 7","title":"ROR rotate right"},{"location":"instructions/#rti-return-from-interrupt","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) return_i RTI Return from Interrupt pull SR, pull PC N Z C I D V from stack addressing assembler opc bytes cyles -------------------------------------------- implied RTI 40 1 6","title":"RTI return from interrupt"},{"location":"instructions/#rts-return-from-subroutine","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) return RTS Return from Subroutine pull PC, PC+1 -> PC N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- implied RTS 60 1 6","title":"RTS return from subroutine"},{"location":"instructions/#sbc-subtract-with-carry","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a-imm a-mem a-mem,x a-mem,y a-(mem,x) a-(mem),y SBC Subtract Memory from Accumulator with Borrow A - M - C -> A N Z C I D V + + + - - + addressing assembler opc bytes cyles -------------------------------------------- immidiate SBC #oper E9 2 2 zeropage SBC oper E5 2 3 zeropage,X SBC oper,X F5 2 4 absolute SBC oper ED 3 4 absolute,X SBC oper,X FD 3 4* absolute,Y SBC oper,Y F9 3 4* (indirect,X) SBC (oper,X) E1 2 6 (indirect),Y SBC (oper),Y F1 2 5*","title":"SBC subtract with carry"},{"location":"instructions/#sec-set-carry","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) c+ SEC Set Carry Flag 1 -> C N Z C I D V - - 1 - - - addressing assembler opc bytes cyles -------------------------------------------- implied SEC 38 1 2","title":"SEC set carry"},{"location":"instructions/#sed-set-decimal","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) d+ SED Set Decimal Flag 1 -> D N Z C I D V - - - - 1 - addressing assembler opc bytes cyles -------------------------------------------- implied SED F8 1 2","title":"SED set decimal"},{"location":"instructions/#sei-set-interrupt-disable","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) i+ SEI Set Interrupt Disable Status 1 -> I N Z C I D V - - - 1 - - addressing assembler opc bytes cyles -------------------------------------------- implied SEI 78 1 2","title":"SEI set interrupt disable"},{"location":"instructions/#sta-store-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem=a mem,x=a mem,y=a (mem,x)=a (mem),y=a STA Store Accumulator in Memory A -> M N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- zeropage STA oper 85 2 3 zeropage,X STA oper,X 95 2 4 absolute STA oper 8D 3 4 absolute,X STA oper,X 9D 3 5 absolute,Y STA oper,Y 99 3 5 (indirect,X) STA (oper,X) 81 2 6 (indirect),Y STA (oper),Y 91 2 6","title":"STA store accumulator"},{"location":"instructions/#stx-store-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem=x STX Store Index X in Memory X -> M N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- zeropage STX oper 86 2 3 zeropage,Y STX oper,Y 96 2 4 absolute STX oper 8E 3 4","title":"STX store X"},{"location":"instructions/#sty-store-y","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) mem=y STY Sore Index Y in Memory Y -> M N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- zeropage STY oper 84 2 3 zeropage,X STY oper,X 94 2 4 absolute STY oper 8C 3 4","title":"STY store Y"},{"location":"instructions/#tax-transfer-accumulator-to-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x=a TAX Transfer Accumulator to Index X A -> X N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied TAX AA 1 2","title":"TAX transfer accumulator to X"},{"location":"instructions/#tay-transfer-accumulator-to-y","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) y=a TAY Transfer Accumulator to Index Y A -> Y N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied TAY A8 1 2","title":"TAY transfer accumulator to Y"},{"location":"instructions/#tsx-transfer-stack-pointer-to-x","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) x=s TSX Transfer Stack Pointer to Index X SP -> X N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied TSX BA 1 2","title":"TSX transfer stack pointer to X"},{"location":"instructions/#txa-transfer-x-to-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a=x TXA Transfer Index X to Accumulator X -> A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied TXA 8A 1 2","title":"TXA transfer X to accumulator"},{"location":"instructions/#txs-transfer-x-to-stack-pointer","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) s=x TXS Transfer Index X to Stack Register X -> SP N Z C I D V - - - - - - addressing assembler opc bytes cyles -------------------------------------------- implied TXS 9A 1 2","title":"TXS transfer X to stack pointer"},{"location":"instructions/#tya-transfer-y-to-accumulator","text":"Acc Implied Imm Mem Mem,X Mem,Y (Mem,X) (Mem),Y (Mem) a=y TYA Transfer Index Y to Accumulator Y -> A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- implied TYA 98 1 2","title":"TYA transfer Y to accumulator"},{"location":"instructions/#note","text":"* add 1 to cycles if page boundery is crossed ** add 1 to cycles if branch occurs on same page add 2 to cycles if branch occurs to different page","title":"Note"},{"location":"instructions/#legend-to-flags","text":"+ .... modified - .... not modified 1 .... set 0 .... cleared M6 .... memory bit 6 M7 .... memory bit 7","title":"Legend to Flags"},{"location":"known-bugs/","text":"Accidential bank switching can occur when branch instruction jumps back from last bank to previous bank. Example: branch instruction at $1F0C jumps back to $1EF4 because branching across page boundary is done in 6502 in two steps (first compute lower address, then higher), CPU does extra memory fetch from $1FF4 (old high address byte, new low address). This can trigger unwanted bank switching. Currently there is no way of detecting this. Far calls placed in inline blocks do not work correctly if the inline is used in different bank that it was defined. Local labels can't be accessed across certain language constructs (like far calls). Local labels before and after such construct appear to be in different local namespaces. Code parser can hang on unexpected input characters.","title":"Known Bugs"},{"location":"known-bugs/#_1","text":"Accidential bank switching can occur when branch instruction jumps back from last bank to previous bank. Example: branch instruction at $1F0C jumps back to $1EF4 because branching across page boundary is done in 6502 in two steps (first compute lower address, then higher), CPU does extra memory fetch from $1FF4 (old high address byte, new low address). This can trigger unwanted bank switching. Currently there is no way of detecting this. Far calls placed in inline blocks do not work correctly if the inline is used in different bank that it was defined. Local labels can't be accessed across certain language constructs (like far calls). Local labels before and after such construct appear to be in different local namespaces. Code parser can hang on unexpected input characters.","title":""},{"location":"projects/","text":"Ataventure by DMA TIM1T by Cluster & DMA K65 used only for audio Ascend by Cluster & DMA Derivative 2600 by Cluster & DMA","title":"Projects"},{"location":"projects/#_1","text":"Ataventure by DMA TIM1T by Cluster & DMA K65 used only for audio Ascend by Cluster & DMA Derivative 2600 by Cluster & DMA","title":""},{"location":"syntax/","text":"Comments K65 uses C -like comments. // this is a line comment /* this is a block comment */ Variable declaration Variables in K65 are names given to chosen memory addresses. Examples of variable declaration: var foo=0x80 // declares 'foo' at address 0x80 var foo2 // declares 'foo2' at address 0x81 (next after previous var) var foo3, foo4 // multiple declarations per line allowed var bar[10], bar2[10] // [] specifies variable size in bytes (address increment for next var) var bar3 ? // adding '?' at the end of var declaration makes compiler print var addresses Constant declaration The best way of defining constants is using the evaluator . Constants defined this way can be changed at any moment during compilation. Constants can be any value of floating point type. When used within 6502 instruction, they are converted to single byte by rounding to nearest integer and AND -ing with 0xFF (this way negative values are represented in U2 form). Examples: [ // square brace starts evaluator expression MY_CONSTANT = 5, // define constants SOME_NUMBER = 0x13 ] // end of evaluator expression Bank selection While default bank can be chosen in file list for each file, a file can span across multiple banks. Active bank can be changed at any point in the file. Example: bank my_bank // from now on all code and data will go to 'my_bank' Data block definition Data blocks are defined using data keyword. Defining data block at the same time defines a label to its first element, so the block is accessibl using simple indexing, like MyData,x . Datablocks can have optional alignment or no-page-crossing restrictions enabled. Examples: data MyData { align 16 // align to 16 byte boundary 1 2 3 4 5 6 7 8 // data bytes folow } data MyData2 { align 256 + 8 // align to 8 bytes after page boundary (lower address byte will be 0x08) 1 2 3 4 5 6 7 8 // data bytes folow } data MyData3 { nocross // the data will fit completely inside single page, but can be at any offset within it 1 2 3 4 5 6 7 8 // data bytes folow } data MyData { address 0x5000 // fixed memory address 1 2 3 4 5 6 7 8 // data bytes folow } data sprite { align 256 // image <file> <x0> <y0> <byte> <repeat> - gather bits from image // <file> - file name without \".bmp\" extension // <x0> <y0> - first pixel to scan // <byte> - scanning mode for each single byte starting with MSB (count+direction) // <repeat> - scanning mode for consecutive bytes (count+direction) image sprites 0 0 8> 16v // start at pixel (0,0), each byte is 8 bits to the right, repeat 16 times going up image sprites 10 0 8> 16v // do the same from (10,0) image sprites 20 0 8> 16v // and again starting at (20,0) } data fonts { address 0x5000 image \"data/font\" 0 0 8> 8v tiles 8 0 31 image \"data/font\" 0 8 8> 8v tiles 8 0 31 image \"data/font\" 0 16 8> 8v tiles 8 0 31 image \"data/font\" 0 24 8> 8v tiles 8 0 31 } data table { address 0x2000 binary \"table.bin\" } data SineX { align 256 0 for x=0..213 eval [ (sin(x/212*pi*2)*.499+.499)*130 ] } data SineY { align 256 0 for x=0..255 eval [ (sin(x/256*pi*2)*.499+.499)*180+1 ] } Compile-time Evaluator The K65 compiler has embedded evaluator that always executes at compile-time. The evaluator can perform arbitrary math operations which results are inlined in the final code as immediates. The evaluator can also set and use global compiler constants. The evaluator is explained in detail on K65 Evaluator page. Code sections Executable code in K65 compiler is specified in sections. There currently supported types of code sections are: main This function being program entry point. main { a=0 // set accumulator to 0 {} always // loop forever } func User defined function, that can be called from the code. func inc_x { x++ // increments X register and returns } // RTS is added automatically naked Just like func , but no RTS is added automatically at the end. naked inc_x_twice { x++ // increments X register goto inc_x // jump to previously defined inc_x (saves stack) } // no RTS here; make sure function never reaches here inline User defined macro that is inlined in the code when used. inline inc_y { y++ } Functions and inlines are used simply by specifying their names, which places JSR opcode or inlines the code. Function and inline calls do not pass any parameters. Any potential parameter and return value handling must be handled explicitly by the programmer using either registers, stack or predetermined memory locations. func test { inc_x // this will use JSR instruction to call 'inc_x' defined earlier inc_y // this will inline the 'inc_y' inline - note that it will not add any overhead compared to simple 'y++' } Far calls Functions can also be called with far prefix to mark that the target function is in another bank, than the current one. The bankswitching mechanism used is defined by the linker. Inlines do not use far prefix, because the code is simply inlined. NOTE : if far call is used within inline make sure to use such inline with care - inlining such inline in another bank will copy the inline code directly, which will usually result in improper bankswitching and program crash. func test2_in_different_bank { far inc_x } This page is still under construction - much of the infrmation is still to be filled","title":"Syntax"},{"location":"syntax/#_1","text":"","title":""},{"location":"syntax/#comments","text":"K65 uses C -like comments. // this is a line comment /* this is a block comment */","title":"Comments"},{"location":"syntax/#variable-declaration","text":"Variables in K65 are names given to chosen memory addresses. Examples of variable declaration: var foo=0x80 // declares 'foo' at address 0x80 var foo2 // declares 'foo2' at address 0x81 (next after previous var) var foo3, foo4 // multiple declarations per line allowed var bar[10], bar2[10] // [] specifies variable size in bytes (address increment for next var) var bar3 ? // adding '?' at the end of var declaration makes compiler print var addresses","title":"Variable declaration"},{"location":"syntax/#constant-declaration","text":"The best way of defining constants is using the evaluator . Constants defined this way can be changed at any moment during compilation. Constants can be any value of floating point type. When used within 6502 instruction, they are converted to single byte by rounding to nearest integer and AND -ing with 0xFF (this way negative values are represented in U2 form). Examples: [ // square brace starts evaluator expression MY_CONSTANT = 5, // define constants SOME_NUMBER = 0x13 ] // end of evaluator expression","title":"Constant declaration"},{"location":"syntax/#bank-selection","text":"While default bank can be chosen in file list for each file, a file can span across multiple banks. Active bank can be changed at any point in the file. Example: bank my_bank // from now on all code and data will go to 'my_bank'","title":"Bank selection"},{"location":"syntax/#data-block-definition","text":"Data blocks are defined using data keyword. Defining data block at the same time defines a label to its first element, so the block is accessibl using simple indexing, like MyData,x . Datablocks can have optional alignment or no-page-crossing restrictions enabled. Examples: data MyData { align 16 // align to 16 byte boundary 1 2 3 4 5 6 7 8 // data bytes folow } data MyData2 { align 256 + 8 // align to 8 bytes after page boundary (lower address byte will be 0x08) 1 2 3 4 5 6 7 8 // data bytes folow } data MyData3 { nocross // the data will fit completely inside single page, but can be at any offset within it 1 2 3 4 5 6 7 8 // data bytes folow } data MyData { address 0x5000 // fixed memory address 1 2 3 4 5 6 7 8 // data bytes folow } data sprite { align 256 // image <file> <x0> <y0> <byte> <repeat> - gather bits from image // <file> - file name without \".bmp\" extension // <x0> <y0> - first pixel to scan // <byte> - scanning mode for each single byte starting with MSB (count+direction) // <repeat> - scanning mode for consecutive bytes (count+direction) image sprites 0 0 8> 16v // start at pixel (0,0), each byte is 8 bits to the right, repeat 16 times going up image sprites 10 0 8> 16v // do the same from (10,0) image sprites 20 0 8> 16v // and again starting at (20,0) } data fonts { address 0x5000 image \"data/font\" 0 0 8> 8v tiles 8 0 31 image \"data/font\" 0 8 8> 8v tiles 8 0 31 image \"data/font\" 0 16 8> 8v tiles 8 0 31 image \"data/font\" 0 24 8> 8v tiles 8 0 31 } data table { address 0x2000 binary \"table.bin\" } data SineX { align 256 0 for x=0..213 eval [ (sin(x/212*pi*2)*.499+.499)*130 ] } data SineY { align 256 0 for x=0..255 eval [ (sin(x/256*pi*2)*.499+.499)*180+1 ] }","title":"Data block definition"},{"location":"syntax/#compile-time-evaluator","text":"The K65 compiler has embedded evaluator that always executes at compile-time. The evaluator can perform arbitrary math operations which results are inlined in the final code as immediates. The evaluator can also set and use global compiler constants. The evaluator is explained in detail on K65 Evaluator page.","title":"Compile-time Evaluator"},{"location":"syntax/#code-sections","text":"Executable code in K65 compiler is specified in sections. There currently supported types of code sections are:","title":"Code sections"},{"location":"syntax/#main","text":"This function being program entry point. main { a=0 // set accumulator to 0 {} always // loop forever }","title":"main"},{"location":"syntax/#func","text":"User defined function, that can be called from the code. func inc_x { x++ // increments X register and returns } // RTS is added automatically","title":"func"},{"location":"syntax/#naked","text":"Just like func , but no RTS is added automatically at the end. naked inc_x_twice { x++ // increments X register goto inc_x // jump to previously defined inc_x (saves stack) } // no RTS here; make sure function never reaches here","title":"naked"},{"location":"syntax/#inline","text":"User defined macro that is inlined in the code when used. inline inc_y { y++ } Functions and inlines are used simply by specifying their names, which places JSR opcode or inlines the code. Function and inline calls do not pass any parameters. Any potential parameter and return value handling must be handled explicitly by the programmer using either registers, stack or predetermined memory locations. func test { inc_x // this will use JSR instruction to call 'inc_x' defined earlier inc_y // this will inline the 'inc_y' inline - note that it will not add any overhead compared to simple 'y++' }","title":"inline"},{"location":"syntax/#far-calls","text":"Functions can also be called with far prefix to mark that the target function is in another bank, than the current one. The bankswitching mechanism used is defined by the linker. Inlines do not use far prefix, because the code is simply inlined. NOTE : if far call is used within inline make sure to use such inline with care - inlining such inline in another bank will copy the inline code directly, which will usually result in improper bankswitching and program crash. func test2_in_different_bank { far inc_x } This page is still under construction - much of the infrmation is still to be filled","title":"Far calls"},{"location":"todo/","text":"Here is my current list of things still to be done in K65 compiler. Simple signal errors on undefined character in string #if's within data #if's within code support for binary numbers report error when section names are reused (e.g. in inline section) correct support of <flag>+? and <flag>-? branch operators >={...}>= loops and similar support for negative eval results extend binary operations in eval change ^ operator to bitwise xor in eval 256-byte data section should work with nocross add fixed address option for sections add option to place sections in multiple banks fix lexer hanging on invalid input Medium support for custom palettes mark section as referenced if ANY of its labels are referenced array support option to force full addressing with zeropage addresses include raw binary data from file extend computation on labels (compute Label1 - Label2 + Offset ) switch to external image loader library (OpenIL?) Hard/large macros pure assembly sections alternate bankswitching schemes alternate platforms per-instruction bank bits linker refactoring generalized linker bank blocks jumping bank checking when getting addresses option to override ORG and RORG execution address lazy code sections target files and names .bin .lst .sym in config file make LST files compatible with DASM/Stella language reference document","title":"To Do"},{"location":"todo/#_1","text":"Here is my current list of things still to be done in K65 compiler.","title":""},{"location":"todo/#simple","text":"signal errors on undefined character in string #if's within data #if's within code support for binary numbers report error when section names are reused (e.g. in inline section) correct support of <flag>+? and <flag>-? branch operators >={...}>= loops and similar support for negative eval results extend binary operations in eval change ^ operator to bitwise xor in eval 256-byte data section should work with nocross add fixed address option for sections add option to place sections in multiple banks fix lexer hanging on invalid input","title":"Simple"},{"location":"todo/#medium","text":"support for custom palettes mark section as referenced if ANY of its labels are referenced array support option to force full addressing with zeropage addresses include raw binary data from file extend computation on labels (compute Label1 - Label2 + Offset ) switch to external image loader library (OpenIL?)","title":"Medium"},{"location":"todo/#hardlarge","text":"macros pure assembly sections alternate bankswitching schemes alternate platforms per-instruction bank bits linker refactoring generalized linker bank blocks jumping bank checking when getting addresses option to override ORG and RORG execution address lazy code sections target files and names .bin .lst .sym in config file make LST files compatible with DASM/Stella language reference document","title":"Hard/large"}]}